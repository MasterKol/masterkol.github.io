/* autogenerated by Processing revision 1286 on 2022-12-13 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.concurrent.atomic.AtomicBoolean;
import java.util.Arrays;
import java.util.concurrent.atomic.AtomicInteger;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class Ray_Tracing_Global_Illumination_copy extends PApplet {

// potential todo:
// add ability to save scene
// add ability to upload texture map
// figure out if ReSTIR is compatible and implement it
// add photorealistic bloom
// add normal maps



Camera Cam = new Camera(new PVector(10, 10, 5), new PVector(0,0,0), PI/4);//PI/5*2
//Camera Cam = new Camera(new PVector(1.68, 2.115, 1.33), new PVector(1.885, 2.253, 2.299), PI/4); // new PVector(5, 5, 2.5), new PVector(0,0,0), PI/4
ArrayList<Object> Objs = new ArrayList<Object>(); // list of scene objects

// 2524 lines, 53.88% GUI, 46.11% Ray Tracer
// 3052 lines 11/1
// 3481 lines 11/8 (after adding quaternions, translation, and rotation)
// 4304 lines 11/13 (after adding mesh & KD Tree)

PVector preResLightDir = new PVector(0.5f, 0.75f, 1).normalize(); // direcition light comes from in preres mode

float goldenConj = 2 / (sqrt(5) + 1);               // reciprocal of the golden ratio
float plasticConj = 1 / 1.324717957244746025960909f; // reciprocal of the plastic constant

int Res = 3;          // size of a render pixel in screen space pixels (higher = faster but lower resolution)
int samples = 20;     // number of samples taken from non-specular surfaces (lower = faster but slower convergence)

int drawWidth = 600;  // width of the view screen
int drawHeight = 600; // height of the view screen

int guiWidth = 300;   // width of the GUI

int maxBounces = 8;   // maximum number of bounces for a ray in the sceen (lower is faster but worse quality)

int ImageWidth, ImageHeight; // width and height of the image (not the same as size of view screen because image resolution is dynamic)

Color[] image;        // stores raw data accumulated from ray tracer (no post processing)
Color[] finalRender;  // postprocessed image that is drawn to the screen

float bloomStrength = 2; // strength of bloom
float bloomThreshold = 1;  // minimum threshold for bloom to begin
int bloomSize = 5;        // size / spread of bloom effect
float exposure = 1;       // increases image brightness
float contrast = 0;       // increases image contrast
int pixelsDrawn = 0;      // stores the number of pixels drawn for the current frame (used for progress bar)

Color skyColor = new Color(0.7f, 0.8f, 1);
float skyBrightness = 0.8f;

int tileSplit = 4;          // how many sub-regions to break the image up into (# regions = tileSplit ^ 2)

int guiHeight;              // height of the GUI (should always equal Applet height but I pulled it out just incase I want to change it later)

float apertureSize = 0;     // size of the camera's aperture (leads to depth of field effect if non-zero)
float focalLength = 5;      // world space distance to focal point (objects around this distance will be in focus, others will be out of focus)

PImage imgToSave;           // stores image that will be saved until it is saved, this is done because image might update after save button is pressed

PVector cameraAngle = new PVector(3.88f, -0.3f);//new PVector(3.733, -0.25);

boolean drawingDepthBuffer = false; // should depth buffer be drawn or not?
float[] depthBuffer;                // stores the current depth buffer (not currently used, mostly for debug purposes)
boolean[] selObjectBuffer;          // boolean array telling if the currently selected object was hit at this pixel locaiton, used for drawing object outline

 public void settings(){
  size(drawWidth + guiWidth, drawHeight);
  //size(displayWidth, displayHeight - 136);
}

 public void setup(){
  // inital setup
  setupKeys();
  initalizeBars();
  Cam.UpdateCamera();
  resetBuffers();
  
  guiHeight = height;
  
  // rest of setup function is default scene construction (all for debug purposes)
    
  Objs.add(new Sphere(new PVector(0, 0, 4), 1.95f, new Transparent(1.5f, new Color(1, 1, 1), 0, 0)));
  Objs.add(new Plane(new PVector(0,0,0), new PVector(0,0,1), 10, 10, 0, new Diffuse(new Color(0.676f, 0.852f, 0.889f))));
  
  Objs.add(new Disc(new PVector(0,0,15), new PVector(0, 0, 1), 5, new Emissive(new Color(1, 1, 1), 7)));
  Objs.add(new Box(new PVector(-2, -4, 2), new PVector(2, 2, 2), new Diffuse(new Color(1, 0.5f, 0.5f))));
  Objs.add(new Box(new PVector(0.5f, -5.5f, 0.5f), new PVector(0.5f, 0.5f, 0.5f), new Diffuse(new Color(1, 0.8f, 0.5f))));
  Objs.get(Objs.size() - 1).SetRotation(GetRotationTo(new PVector(0.5f, 0.3f, 1), 0.4f));
  Objs.add(new Sphere(new PVector(1.2f, -0.4f, 0.5f), 0.5f, new Metal(new Color(0.8f, 0.8f, 0.8f))));
}

int fibA, fibB;

boolean bloomToggle = true;      // controls if bloom is active or not
AtomicBoolean threadFinished = new AtomicBoolean(true);   // CHANGE TO ATOMIC BOOLEAN!
boolean pkeyPressed = false;    // was a key pressed on the previous frame?
boolean pmousePressed = false;  // was mouse pressed on the previous frame?
int StartTime = 0;        // time when render was last started/resumed (in ms since start of applet)
boolean paused = false;   // is final render paused
boolean drawing = false;  // is render actively being worked on
                          // drawing and paused are broken up because a render may be paused but the current frame will still finish drawing (so drawing â‰  !paused)

boolean imageUpdated = false; // if true redraw render (on new frame or change of settings)

Table preferences;
int timeLastFrame = 0;     // time spent rendering the previous frame
int totalRenderTime = 0;   // total time spent on this render
int raysThisFrame = 0;     // # rays traced so far this 'frame'
long totalTracedRays = 0;  // # rays traced since starting this render
int raysLastFrame = 0; // # rays traced in the previous 'frame'

boolean preRes = true;         // tells program whether to draw preres mode or render mode
boolean preresUpdate = true;   // if true redraws the preres then sets itself to false

boolean draggingCamera = false;// tells if camera is being dragged (panned) or if the user is just clicking
PVector pressLocation = new PVector(0,0); // used for tracking where the mouseDown event was

 public void draw(){
  keyboardStartFrame();
  drawGUI();
  
  if(imageUpdated){
    Blit();
    imageUpdated = false;
  }
  
  if(mousePressed && !pmousePressed){ // if mousePressed down store press location
    pressLocation.x = mouseX;
    pressLocation.y = mouseY;
  }
  
  if(preRes && mousePressed && (draggingCamera || pressLocation.x < drawWidth) && (abs(mouseX - pressLocation.x) > 2 || abs(mouseY - pressLocation.y) > 2)){
    // if the mouse is pressed, and in the view window, and has moved by more than 2 pixels in any direction then set mouse as being dragged
    draggingCamera = true;
  }else if(!mousePressed){
    draggingCamera = false; // if mouse not pressed then reset camera dragged
  }
  
  if(preRes && focused){ // manage camera movement if in preRes and Applet has focus
    Cam.Move();
  }
  
  if(preRes){
    moveObjects();
  }
  
  if(preRes && preresUpdate){ // redraw preres if there was an update
    preresUpdate = false;
    drawPreRes();
    Blit();
    DrawAxes();
  }else if(!preRes && threadFinished.get() && (drawing || !paused)){ // at the start of each frame update stats
    if(drawing){
      timeLastFrame = millis() - StartTime;
      totalRenderTime += timeLastFrame;
      totalTracedRays += raysThisFrame;
      raysLastFrame = raysThisFrame;
      raysThisFrame = 0;
      pixelsDrawn = 0;
      FrameNum++;
      
      for(int i = 0; i < image.length; i++){
        image[i].add(buffer[i]);
      }
      
      imageUpdated = true;
    }
    drawing = !paused;
    if(!paused){
      StartTime = millis();
      threadFinished.set(false);
      thread("DrawFrameMT"); // call the function 'DrawFrameMT' in a seperate thread
    }
  }
  
  if(tileDivisionsBar.locked){ // if tileDivisions bar is being interacted with draw tile divisions
    stroke(0);
    strokeWeight(1);
    for(int i = 0; i < tileSplit-1; i++){
      line((float)(i + 1) / (tileSplit) * drawWidth, 0, (float)(i + 1) / (tileSplit) * drawWidth, drawHeight);
      line(0, (float)(i + 1) / (tileSplit) * drawHeight, drawWidth, (float)(i + 1) / (tileSplit) * drawHeight);
    }
    preresUpdate = true;
  }
  
  pkeyPressed = keyPressed;
  pmousePressed = mousePressed;
  keyboardEndFrame();
}
 public void Blit(){
  if(bloomToggle){
    // bloom works by subtracting threshold 
    for(int i = 0; i < image.length; i++){ // add bloom
      bloom[i] = image[i].copy().sub(contrast).div(FrameNum / exposure * (1 - contrast)).sub(bloomThreshold);
    }
    
    Blur(bloom, bloom, ImageWidth, ImageHeight, bloomSize);
    
    for(int i = 0; i < image.length; i++){
      finalRender[i].copy(image[i]).div(FrameNum);
      finalRender[i].sub(contrast).mult(exposure / (1 - contrast)).add(bloom[i].mult(bloomStrength));
      //finalRender[i].sub(0.5).mult(contrast).add(0.5 + exposure);
    }
  }else{
    for(int i = 0; i < image.length; i++){
      finalRender[i].copy(image[i]).div(FrameNum);
      finalRender[i].sub(contrast).mult(exposure / (1 - contrast));
      //finalRender[i].sub(0.5).mult(contrast).add(0.5 + exposure);
    }
  }
  
  if(drawingDepthBuffer && preRes){
    //println("X");
    /*for(int i = 0; i < image.length; i++){
      finalRender[i] = new Color(1 / (depthBuffer[i] + 0.1));
    }*/
    for(int i = 0; i < image.length; i++){
      if(depthBuffer[i] > focalLength + 0.1f / (0.0001f + apertureSize)){
        finalRender[i] = dot(finalRender[i], new Color(1, 0.6f, 0.6f));
      }else if(depthBuffer[i] > focalLength - 0.1f / (0.0001f + apertureSize)){
        finalRender[i] = dot(finalRender[i], new Color(0.6f, 1, 0.6f));
      }
    }
    drawingDepthBuffer = false;
  }
  
  loadPixels();
  
  if(preRes && objectSelected){
    int n = 0;
    for(int j = 0; j < ImageHeight; j++){
      for(int i = 0; i < ImageWidth; i++){
        if(!selObjectBuffer[n] &&
              ((i > 0 && selObjectBuffer[n-1]) || (i < ImageWidth-1 && selObjectBuffer[n+1]) ||
              (j > 0 && selObjectBuffer[n-ImageWidth]) || (j < ImageHeight - 1 && selObjectBuffer[n+ImageWidth]))){
          finalRender[n] = new Color(0.988f, 0.729f, 0);
        }else{
          finalRender[n] = ACESFitted(finalRender[n]);
        }
        n++;
      }
    }
  }else{
    for(int i = 0; i < image.length; i++){
      finalRender[i] = ACESFitted(finalRender[i]);
    }
  }
  
  int c;
  int n = 0;
  Color C, B;
  for(int j = 0; j < ImageHeight; j++){
    for(int i = 0; i < ImageWidth; i++){
      c = finalRender[n++].getcolor();
      for(int a = 0; a < Res; a++){
        for(int b = 0; b < Res; b++){
          pixels[i*Res + a + (j*Res + b)*width] = c;
        }
      }
    }
  }
  
  updatePixels();
}

 public void resetBuffers(){
  ImageWidth = floor((float)drawWidth / Res);
  ImageHeight = floor((float)drawHeight / Res);
  
  image = new Color[ImageWidth * ImageHeight];
  bloom = new Color[image.length];
  finalRender = new Color[image.length];
  buffer = new Color[image.length];
  depthBuffer = new float[image.length];
  selObjectBuffer = new boolean[image.length];
  
  for(int i = 0; i < image.length; i++){
    image[i] = new Color(0);
    bloom[i] = new Color(0);
    finalRender[i] = new Color(0);
    //depthBuffer[i] = 0;
    buffer[i] = new Color(0);
  }
}

Color[] ACESInputMat = new Color[]{
    new Color(0.59719f, 0.35458f, 0.04823f),
    new Color(0.07600f, 0.90834f, 0.01566f),
    new Color(0.02840f, 0.13383f, 0.83777f)
};

// ODT_SAT => XYZ => D60_2_D65 => sRGB
Color[] ACESOutputMat = new Color[]{
    new Color( 1.60475f, -0.53108f, -0.07367f),
    new Color(-0.10208f,  1.10813f, -0.00605f),
    new Color(-0.00327f, -0.07276f,  1.07602f)
};

 public Color RRTAndODTFit(Color v)
{
    //Color a = v * (v + 0.0245786f) - 0.000090537;
    //Color b = v * (0.983729f * v + 0.4329510f) + 0.238081;
    //return a / b;
    Color a = v.copy().add(0.0245786f).mult(v).sub(0.000090537f);
    Color b = v.copy().mult(0.983729f).add(0.4329510f).mult(v).add(0.238081f);
    return a.div(b);
}

 public Color ACESFitted(Color c)
{
    c = matMul(c, ACESInputMat);

    // Apply RRT and ODT
    c = RRTAndODTFit(c);

    c = matMul(c, ACESOutputMat);

    // Clamp to [0, 1]
    c.r = constrain(c.r, 0, 1);
    c.g = constrain(c.g, 0, 1);
    c.b = constrain(c.b, 0, 1);

    return c;
}
 public void Blur(Color[] I, Color[] trgt, int w, int h, int r){
  Color[] inter = new Color[I.length];
  for(int i = 0; i < inter.length; i++){
    inter[i] = new Color(0);
  }
  
  boxBlurH(I, inter, w, h, r);
  boxBlurT(inter, I, w, h, r);
  boxBlurH(I, inter, w, h, r);
  boxBlurT(inter, I, w, h, r);
  boxBlurH(I, inter, w, h, r);
  boxBlurT(inter, I, w, h, r);
  
  for(int i = 0; i < inter.length; i++){
    trgt[i].copy(I[i]);
  }
}

 public void boxBlurH(Color[] I, Color[] trgt, int w, int h, int r){
  float scf = 1.0f / (r+r+1);
  int ti, li, ri;
  Color fv, lv, val;
  for(int i = 0; i < h; i++){
    ti = i * w;
    li = ti;
    ri = ti + r;
    
    fv = I[ti];
    lv = I[ti + w - 1];
    val = fv.copy().mult(r+1);
    for(int j = 0; j < r; j++){val.add(I[ti + j]);}
    for(int j = 0; j <= r; j++){
      val.add(I[ri++]).sub(fv);
      trgt[ti++].copy(val).mult(scf);
    }
    for(int j = r+1; j < w-r; j++){
      val.add(I[ri++]).sub(I[li++]);
      trgt[ti++].copy(val).mult(scf);
    }
    for(int j = w-r; j < w; j++){
      val.add(lv).sub(I[li++]);
      trgt[ti++].copy(val).mult(scf);
    }
  }
}

 public void boxBlurT(Color[] I, Color[] trgt, int w, int h, int r){
  float scf = 1.0f / (r+r+1);
  int ti, li, ri;
  Color fv, lv, val;
  for(int i = 0; i < w; i++){
    ti = i;
    li = ti;
    ri = ti + r * w;
    
    fv = I[ti];
    lv = I[ti + w * (h-1)];
    val = fv.copy().mult(r+1);
    for(int j = 0; j < r; j++){val.add(I[ti + j*w]);}
    for(int j = 0; j <= r; j++){
      val.add(I[ri]).sub(fv); ri += w;
      trgt[ti].copy(val).mult(scf); ti += w;
    }
    for(int j = r+1; j < h-r; j++){
      val.add(I[ri]).sub(I[li]); ri += w; li += w;
      trgt[ti].copy(val).mult(scf); ti += w;
    }
    for(int j = w-r; j < w; j++){
      val.add(lv).sub(I[li]); li += w;
      trgt[ti].copy(val).mult(scf); ti += w;
    }
  }
}
class Camera{
  PVector w = new PVector(0, 0, -1); // world up
  PVector t/*forwards*/, b/*left/right*/, v/*up/down*/, g, qx, qy, p1m;
  PVector Pos, Target;
  float Fov;
  Camera(PVector CameraPos, PVector ViewTarget, float fov){
    Pos = CameraPos;
    Target = ViewTarget;
    Fov = fov;
    //UpdateCamera(CameraPos, ViewTarget, fov);
  }
  
   public void UpdateCamera(PVector CameraPos, PVector ViewTarget, float fov){
    Pos = CameraPos;
    //Target = ViewTarget;
    //Target = PVector.add(Pos, new PVector(cos(cameraAngle.x) * cos(cameraAngle.y), sin(cameraAngle.x) * cos(cameraAngle.y), sin(cameraAngle.y)));
    Fov = fov;
    //t = PVector.sub(Target, Pos);
    //t.normalize();
    t = new PVector(sin(cameraAngle.x) * cos(cameraAngle.y), cos(cameraAngle.x) * cos(cameraAngle.y), sin(cameraAngle.y));
    b = w.cross(t);
    b.normalize();
    v = t.cross(b);
    v.normalize();
    g = new PVector(tan(fov/2), tan(fov/2)*drawHeight/drawWidth);
    qx = PVector.mult(b, 2*g.x/(floor(drawWidth/Res) -1));
    qy = PVector.mult(v, 2*g.y/(floor(drawHeight/Res) -1));
    //qx = Mult(b, 2*g.x/(width-1));
    //qy = Mult(v, 2*g.y/(height-1));
    p1m = PVector.sub(t, PVector.mult(b, g.x)).sub(PVector.mult(v, g.y));
    //println(g, qx, qy, p1m);
  }
  
   public void UpdateCamera(){
    UpdateCamera(Pos, Target, Fov);
  }
  
   public PVector getRay(float x, float y){
    return PVector.mult(qy, y - 1).add(PVector.mult(qx, x - 1).add(p1m)).normalize();
  }
  
   public PVector WorldToScreen(PVector worldVector){
    PVector rpos = PVector.sub(Cam.Pos, worldVector);
    float iz = 1.0f / (t.dot(rpos) * tan(Cam.Fov/2));
    float x = (b.dot(rpos) * iz + 1) / 2 * drawWidth;
    float y = (v.dot(rpos) * iz + 1) / 2 * drawHeight;
    return new PVector(x, y);
  }
  
   public void Move(){
    if(keyPressed){ // move camera around
      Shift('W', t,  0.1f);    // move forwards
      Shift('S', t, -0.1f);    // move backwards
      Shift('D', b,  0.1f);    // move left
      Shift('A', b, -0.1f);    // move right
      Shift(' ', w, -0.1f);    // move up
      Shift(CONTROL, w, 0.1f); // move down
    }
    
    if(draggingCamera && !objectGrabbed && !objectRotating){ // camera panning is disallowed while an object is being translated or rotated
      if(mouseButton == LEFT){ // pan camera
        cameraAngle.x = (cameraAngle.x + (float)(mouseX - pmouseX) / 100 + 2 * PI) % (2 * PI);
        cameraAngle.y = constrain(cameraAngle.y - (float)(mouseY - pmouseY) / 100, -PI/2 + 0.01f, PI/2 - 0.01f);
      }else if(mouseButton == CENTER){ // move camera in plane if middle mouse pressed
        Pos.add(PVector.mult(b, (pmouseX - mouseX) / 100.0f));
        Pos.add(PVector.mult(v, (pmouseY - mouseY) / 100.0f));
      }
      UpdateCamera();
      preresUpdate |= (mouseX != pmouseX) || (mouseY != pmouseY);
    }
  }
  
  // if key corrisponding to keyNum is held then camera is shifted in the direction of 'dir' multiplied by 'scale'
   public void Shift(int keyNum, PVector dir, float scale){
    if(getKey(keyNum).held){
      Pos.add(PVector.mult(dir, scale));
      UpdateCamera();
      preresUpdate = true;
    }
  }
}
class Color{
  float r, g, b;
  
  Color(float r, float g, float b){
    this.r = r;
    this.g = g;
    this.b = b;
  }
  
  Color(float v){
    r = v;
    g = v;
    b = v;
  }
  
  Color(Color c){
    r = c.r;
    g = c.g;
    b = c.b;
  }
  
   public int getcolor(){
    return color(r*255, g*255, b*255);
  }
  
   public Color add(float v){
    r += v;
    g += v;
    b += v;
    return this;
  }
  
   public Color add(Color c){
    r += c.r;
    g += c.g;
    b += c.b;
    return this;
  }
  
   public Color div(float v){
    r /= v;
    g /= v;
    b /= v;
    return this;
  }
  
   public Color div(Color v){
    r /= v.r;
    g /= v.g;
    b /= v.b;
    return this;
  }
  
   public Color mult(float v){
    r *= v;
    g *= v;
    b *= v;
    return this;
  }
  
   public Color mult(Color v){
    r *= v.r;
    g *= v.g;
    b *= v.b;
    return this;
  }
  
   public Color copy(){
    return new Color(r, g, b);
  }
  
   public Color copy(Color s){
    r = s.r;
    g = s.g;
    b = s.b;
    return this;
  }
  
   public Color sub(float v){
    r = max(r - v, 0);
    g = max(g - v, 0);
    b = max(b - v, 0);
    return this;
  }
  
   public Color sub(Color v){
    r = max(r - v.r, 0);
    g = max(g - v.g, 0);
    b = max(b - v.b, 0);
    return this;
  }
  
   public String toString(){
    return str(r) + ", " + str(g) + ", " + str(b);
  }
  
   public Color Log(){
    r = log(r);
    g = log(g);
    b = log(b);
    return this;
  }
  
   public Color Sq(){
    r *= r;
    g *= g;
    b *= b;
    return this;
  }
  
   public float maxValue(){
    return max(max(r, g), b);
  }
  
   public Color Relu(){
    r = max(r, 0);
    g = max(g, 0);
    b = max(b, 0);
    return this;
  }
}

/*Color dot(Color a, Color b){
  return new Color(a.r * b.r / 255, a.g * b.g / 255, a.b * b.b / 255);
}*/

 public Color dot(Color a, Color b){
  return new Color(a.r * b.r, a.g * b.g, a.b * b.b);
}

 public Color add(Color a, Color b){
  return new Color(a.r * b.r, a.g * b.g, a.b * b.b);
}

 public Color matMul(Color c, Color[] mat){
  assert(mat.length == 3);
  /*float r = mat[0].r * c.r + mat[0].g * c.g + mat[0].b * c.b;
  float g = mat[1].r * c.r + mat[1].g * c.g + mat[1].b * c.b;
  c.b = mat[2].r * c.r + mat[2].g * c.g + mat[2].b * c.b;
  c.g = g;
  c.r = r;
  return c;*/
  return new Color(
      mat[0].r * c.r + mat[0].g * c.g + mat[0].b * c.b,
      mat[1].r * c.r + mat[1].g * c.g + mat[1].b * c.b,
      mat[2].r * c.r + mat[2].g * c.g + mat[2].b * c.b
  );
}

 public Color lerpColor(Color a, Color b, float v){
  float vm1 = 1 - v;
  v = constrain(v, 0, 1);
  return new Color(a.r * vm1 + b.r * v, a.g * vm1 + b.g * v, a.b * vm1 + b.b * v);
}

 public Color toColor(int c){
  Color o = new Color(0);
  
  o.r = (float)((c >> 16) & 0xFF) / 255;
  o.g = (float)((c >> 8) & 0xFF) / 255;
  o.b = (float)(c & 0xFF) / 255;
  
  return o;
}
HScrollbar bloomStrenBar =        new HScrollbar(120, 35, 120, 12, "Strength of the bloom effect in the final image");
HScrollbar bloomSizeBar =         new HScrollbar(120, 55, 120, 12, "Radius of blur of the bloom in the final image");
HScrollbar exposureBar =          new HScrollbar(120, 75, 120, 12);
HScrollbar contrastBar =          new HScrollbar(120, 95, 120, 12);
Button toggleRenderButton =       new Button(30, 115, 100, 30, "Pause Render");
Button restartRenderButton =      new Button(170, 115, 100, 30, "Restart Render");
Button saveImageButton =          new Button(30, 155, 100, 30, "Save Image");

HScrollbar cameraXBar =           new HScrollbar(120, 145, 120, 12);
HScrollbar cameraYBar =           new HScrollbar(120, 165, 120, 12);
HScrollbar cameraZBar =           new HScrollbar(120, 185, 120, 12);
HScrollbar cameraThetaBar =       new HScrollbar(120, 205, 120, 12, "Horizontal angle of the camera");
HScrollbar cameraPhiBar =         new HScrollbar(120, 225, 120, 12, "Vertical angle of the camera");
HScrollbar cameraFOVBar =         new HScrollbar(120, 245, 120, 12, "Field of view");
HScrollbar cameraFocalBar =       new HScrollbar(120, 265, 120, 12, "Focal length of camera (only matters if aperture is non 0)");
HScrollbar cameraApertureBar =    new HScrollbar(120, 285, 120, 12, "Radius of the camera's aperture (bigger = smaller region of focus)");
HScrollbar cameraResBar =         new HScrollbar(120, 305, 120, 12, "Size of each pixel, 1 is full res, 2 is half res, etc.");
HScrollbar samplesBar =           new HScrollbar(120, 325, 120, 12, "Number of samples for diffuse objects (currently bugged)");
HScrollbar tileDivisionsBar =     new HScrollbar(120, 345, 120, 12, "Breaks image up to be drawn by individual threads");

HScrollbar skyColorRBar =         new HScrollbar(120, 370, 120, 12);
HScrollbar skyColorGBar =         new HScrollbar(120, 390, 120, 12);
HScrollbar skyColorBBar =         new HScrollbar(120, 410, 120, 12);
HScrollbar skyBrightnessBar =     new HScrollbar(120, 430, 120, 12);

Button startRenderButton =        new Button(215, 10, 80, 20, "Start Render");

Button materialLeftButton =       new Button(60, 0, 20, 20, "<");
Button materialRightButton =      new Button(220, 0, 20, 20, ">");

HScrollbar objectXBar =           new HScrollbar(120, 345, 120, 12);
HScrollbar objectYBar =           new HScrollbar(120, 365, 120, 12);
HScrollbar objectZBar =           new HScrollbar(120, 385, 120, 12);

ScrollArea scrollArea =           new ScrollArea(0, 0, 300, drawHeight);

Button deleteObjectButton =       new Button(110, 340, 100, 20, "Delete Object");

Button addSphereButton =          new Button(110, 340, 100, 20, "Sphere");
Button addPlaneButton =           new Button(110, 365, 100, 20, "Plane");
Button addBoxButton =             new Button(110, 390, 100, 20, "Box");
Button addDiscButton =            new Button(110, 415, 100, 20, "Disc");
Button addMeshButton =            new Button(110, 440, 100, 20, "Mesh");


DrawOverlayCallback overlayCallback; // draws the current overlay in the global image reference frame

boolean objectSelected = false; // all information about object that is currently selected / being translated / rotated
Object selectedObject;
boolean objectGrabbed = false;
boolean objectRotating = false;
PVector originalPosition;
Quaternion originalAngle = new Quaternion(1,0,0,0);
int directions = 0;
PVector selPos = new PVector(0, 0);

 public void drawGUI(){
  overlayCallback = null;
  
  pushMatrix();
  translate(drawWidth, 0);
  
  fill(255);
  noStroke();
  rect(0, 0, guiWidth, guiHeight);
  
  scrollArea.update();
  scrollArea.display();
  translate(0, -scrollArea.currentScroll);
  scrollArea.maxScroll = 130 + 60;
  
  if(preRes){
    
    scrollArea.maxScroll += 280;
    
    textSize(10);
    textLeading(10);
    textAlign(LEFT, TOP);
    
    fill(0);
    text("Change the settings below before you start the render. If you click an object you can change its properties. "
      + "When you're ready click the button to the right.", 15, 5, 200, 50);
    
    startRenderButton.update();
    startRenderButton.display();
    if(!startRenderButton.getState()){ // stuff to do when rendering starts
      startRenderButton.setState(true);
      FrameNum = 0;
      StartTime = millis();
      preRes = false;
      for(int i = 0; i < image.length; i++){
        image[i] = new Color(0);
      }
      
      totalTracedRays = 0;
      raysLastFrame = 0;
      raysThisFrame = 0;
      timeLastFrame = 0;
      totalRenderTime = 0;
      pixelsDrawn = 0;
      
      int t;
      fibA = 1; fibB = 1;
      while(fibA + fibB < samples){
        t = fibA + fibB;
        fibA = fibB;
        fibB = t;
      }
    }
    
    translate(0, 50);
    
    ImageSettings();
    
    PreResGui();
  }else{
    ImageSettings();
    nonPreResGui();
  }
  
  if(!mousePressed && pmousePressed){
    writeSettings();
  }
  
  popMatrix();
  
  if(overlayCallback != null){
    overlayCallback.Draw();
  }
}

 public void PreResGui(){
  fill(0);
  textSize(16);
  textAlign(CENTER);
  text("Camera Settings", guiWidth / 2, 130);
  
  textAlign(LEFT);
  textSize(12);
  textLeading(14);
  
  HDiffBar(cameraXBar, "X Pos", Cam.Pos.x, 1, new barInter(){public void onChange(float v){
    Cam.Pos.x = v;
    Cam.UpdateCamera();
  }});
  
  HDiffBar(cameraYBar, "Y Pos", Cam.Pos.y, 1, new barInter(){public void onChange(float v){
    Cam.Pos.y = v;
    Cam.UpdateCamera();
  }});
  
  HDiffBar(cameraZBar, "Z Pos", Cam.Pos.z, 1, new barInter(){public void onChange(float v){
    Cam.Pos.z = v;
    Cam.UpdateCamera();
  }});
  
  HDiffBar(cameraThetaBar, "Theta", cameraAngle.x * 180 / PI, 6, new barInter(){public void onChange(float v){
    cameraAngle.x = ((v + 360) % 360) * PI / 180;
    Cam.UpdateCamera();
  }});
  
  NormBar(cameraPhiBar, "Phi", cameraAngle.y * 180 / PI, -89.5f, 89.5f, true, new barInter(){public void onChange(float v){
    cameraAngle.y = v * PI / 180;
    Cam.UpdateCamera();
    preresUpdate = true;
  }});
  
  NormBar(cameraFOVBar, "FOV", Cam.Fov, 0.01f, PI/2, true, new barInter(){public void onChange(float v){
    Cam.Fov = v;
    Cam.UpdateCamera();
    preresUpdate = true;
  }});
  
  NormBar(cameraFocalBar, "Focal Length", focalLength, 1, 30, false, new barInter(){public void onChange(float v){
    focalLength = v;
    drawingDepthBuffer = true;
    preresUpdate = true;
  }});
  
  NormBar(cameraApertureBar, "Aperture Size", apertureSize, 0, 2, false, new barInter(){public void onChange(float v){
    apertureSize = v;
    drawingDepthBuffer = true;
    preresUpdate = true;
  }});
  
  NormBar(cameraResBar, "Pixel Size", Res, 1, 10, true, new barInter(){public void onChange(float v){
    Res = round(v);
    resetBuffers();
    Cam.UpdateCamera();
    preresUpdate = true;
  }});
  
  NormBar(samplesBar, "Samples", samples, 1, 100, true, new barInter(){public void onChange(float v){
    samples = round(v);
  }});
  
  tileSplit = round(NormBar(tileDivisionsBar, "Tile Divisions", tileSplit, 1, 6, true));
  
  NormBar(skyColorRBar, "Sky Color Red", skyColor.r, 0, 1, true, new barInter(){public void onChange(float v){
    skyColor.r = v;
    preresUpdate = true;
  }});
  
  NormBar(skyColorGBar, "Sky Color Green", skyColor.g, 0, 1, true, new barInter(){public void onChange(float v){
    skyColor.g = v;
    preresUpdate = true;
  }});
  
  NormBar(skyColorBBar, "Sky Color Blue", skyColor.b, 0, 1, true, new barInter(){public void onChange(float v){
    skyColor.b = v;
    preresUpdate = true;
  }});
  
  NormBar(skyBrightnessBar, "Sky Brightness", skyBrightness, 0, 5, false, new barInter(){public void onChange(float v){
    skyBrightness = max(0, v);
    preresUpdate = true;
  }});
  
  translate(0, 80);
  scrollArea.maxScroll += 80;
  
  if(objectSelected){ // draw information for selected object
    translate(0, 50);
    fill(0);
    textSize(16);
    textAlign(CENTER);
    text("Object Settings", guiWidth / 2, 330);
    
    textAlign(LEFT);
    textSize(12);
    textLeading(14);
    
    deleteObjectButton.update();
    deleteObjectButton.display();
    translate(0, 30);
    
    selectedObject.pos.x = HDiffBar(objectXBar, "X Pos", selectedObject.pos.x, 0.2f);
    selectedObject.pos.y = HDiffBar(objectYBar, "Y Pos", selectedObject.pos.y, 0.2f);
    selectedObject.pos.z = HDiffBar(objectZBar, "Z Pos", selectedObject.pos.z, 0.2f);
    
    Material objectMat = selectedObject.getMaterial();
    
    scrollArea.maxScroll += 190 + selectedObject.getGuiSize() + objectMat.getGuiSize();
    //println(scrollArea.maxScroll);
    
    pushMatrix();
    translate(0, 405);
    selectedObject.drawGui();
    
    translate(0, selectedObject.getGuiSize());
    
    fill(0);
    textSize(16);
    textAlign(CENTER, TOP);
    text("Material Settings", guiWidth / 2, 0);
    
    textAlign(LEFT);
    
    translate(0, 30);
    
    textAlign(CENTER, CENTER);
    textSize(14);
    textLeading(14);
    text(objectMat.getTypeName(), 150, 7);
    
    textSize(12);
    textLeading(14);
    
    int newtype = objectMat.getType();
    materialLeftButton.display();
    materialLeftButton.update();
    if(!materialLeftButton.state){
      materialLeftButton.setState(true);
      newtype = (newtype - 1 + 6) % 6;
    }
    
    materialRightButton.display();
    materialRightButton.update();
    if(!materialRightButton.state){
      materialRightButton.setState(true);
      newtype = (newtype + 1) % 6;
      println(newtype);
    }
    
    if(objectMat.getType() != newtype){
      if(newtype == 0){
        selectedObject.setMaterial(new Emissive(new Color(1, 1, 1), 1));
      }else if(newtype == 1){
        selectedObject.setMaterial(new Diffuse(new Color(1, 1, 1)));
      }else if(newtype == 2){
        selectedObject.setMaterial(new Glossy(new Color(1, 1, 1), 0));
      }else if(newtype == 3){
        selectedObject.setMaterial(new Transparent(1.5f, new Color(1, 1, 1), 0, 0));
      }else if(newtype == 4){
        selectedObject.setMaterial(new Metal(new Color(1, 1, 1)));
      }else if(newtype == 5){
        selectedObject.setMaterial(new Texture());
      }
      preresUpdate = true;
    }
    
    translate(0, 40);
    objectMat.drawGui();
    
    if(!deleteObjectButton.getState()){ // if delete object button is pressed then delete the object
      Objs.remove(selectedObject);
      selectedObject = null;
      objectSelected = false;
      preresUpdate = true;
      deleteObjectButton.setState(true);
    }
    
    popMatrix();
  }else{
    translate(0, 50);
    fill(0);
    textSize(16);
    textAlign(CENTER);
    text("Create Object", guiWidth / 2, 330);
    
    textAlign(LEFT);
    textSize(12);
    textLeading(14);
    
    scrollArea.maxScroll += 105;
    addSphereButton.display();
    addSphereButton.update();
    if(!addSphereButton.getState()){
      Objs.add(new Sphere(new PVector(0, 0, 0), 1, new Diffuse(new Color(1, 1, 1))));
      selectedObject = Objs.get(Objs.size() - 1);
      objectSelected = true;
      preresUpdate = true;
      addSphereButton.setState(true);
    }
    
    addPlaneButton.display();
    addPlaneButton.update();
    if(!addPlaneButton.getState()){
      Objs.add(new Plane(new PVector(0, 0, 0), new PVector(0, 0, 1), 1, 1, 0, new Diffuse(new Color(1, 1, 1))));
      selectedObject = Objs.get(Objs.size() - 1);
      objectSelected = true;
      preresUpdate = true;
      addPlaneButton.setState(true);
    }
    
    addBoxButton.display();
    addBoxButton.update();
    if(!addBoxButton.getState()){
      Objs.add(new Box(new PVector(0, 0, 0), new PVector(1, 1, 1), new Diffuse(new Color(1, 1, 1))));
      selectedObject = Objs.get(Objs.size() - 1);
      objectSelected = true;
      preresUpdate = true;
      addBoxButton.setState(true);
    }
    
    addDiscButton.display();
    addDiscButton.update();
    if(!addDiscButton.getState()){
      Objs.add(new Disc(new PVector(0, 0, 0), new PVector(0, 0, 1), 1, new Diffuse(new Color(1, 1, 1))));
      selectedObject = Objs.get(Objs.size() - 1);
      objectSelected = true;
      preresUpdate = true;
      addDiscButton.setState(true);
    }
    
    addMeshButton.display();
    addMeshButton.update();
    if(!addMeshButton.getState() && !selectingObject.get()){
      selectingObject.set(true);
      selectInput("Select an ObjFile:", "loadObjectGUI");
      addMeshButton.setState(true);
    }
  }
  
  if(!draggingCamera && !mousePressed && pmousePressed && pressLocation.x < drawWidth && pressLocation.y < drawHeight){
    if(objectGrabbed || objectRotating){
      objectGrabbed = false;
      objectRotating = false;
      preresUpdate = true;
    }else{
      PVector dir = Cam.getRay((float)mouseX/Res, mouseY/Res);
      Ray r = new Ray(Cam.Pos.copy(), dir);
      Hit h = new Hit();
      
      preresUpdate = true;
      objectSelected = tracePath(r, h);
      selectedObject = h.object;
    }
  }
}

 public void nonPreResGui(){
  toggleRenderButton.setState(!paused);
  toggleRenderButton.update();
  toggleRenderButton.display();
  paused = !toggleRenderButton.getState();
  
  restartRenderButton.update();
  restartRenderButton.display();
  if(!restartRenderButton.getState()){
    restartRenderButton.setState(true);
    
    preRes = true;
    paused = false;
    drawing = false;
    while(!threadFinished.get());
    
    FrameNum = 1;
    preresUpdate = true;
  }
  
  saveImageButton.update();
  saveImageButton.display();
  if(!saveImageButton.getState()){
    saveImageButton.setState(true);
    
    imgToSave = createImage(ImageWidth, ImageHeight, RGB);
    imgToSave.loadPixels();
    loadPixels();
    for(int x = 0; x < ImageWidth; x++){
      for(int y = 0; y < ImageHeight; y++){
        imgToSave.pixels[x + y * ImageWidth] = pixels[x * Res + y * width * Res];
      }
    }
    imgToSave.updatePixels();
        
    selectOutput("Select File location:", "SaveImage");
  }
  
  // progress bar
  float percentage = 0;
  if(FrameNum == 0){
    percentage = (float)pixelsDrawn / image.length;
  }else{
    percentage = 0.5f * (float)pixelsDrawn / image.length + 0.5f * raysThisFrame / ((float)totalTracedRays / max(FrameNum, 1));
  }
  noFill();
  stroke(0);
  strokeWeight(1);
  rect(10, guiHeight - 170, 140, 10);
  
  fill(0);
  noStroke();
  rect(10, guiHeight - 170, 140 * percentage, 10);
  
  // info
  fill(0);
  text("Frame Number: ", 10, guiHeight - 140);
  text(FrameNum, 140, guiHeight - 140);
  
  text("Total render time: ", 10, guiHeight - 125);
  text(nf(((float)totalRenderTime + (drawing ? (millis() - StartTime) : 0)) / 1000, 0, 3) + " s", 140, guiHeight - 125);
  
  text("Last frame time: ", 10, guiHeight - 110);
  text(timeLastFrame + " ms", 140, guiHeight - 110);
  
  text("Average frame time: ", 10, guiHeight - 95);
  text(totalRenderTime / max(FrameNum, 1) + " ms", 140, guiHeight - 95);
  
  text("Time on this frame: ", 10, guiHeight - 80);
  text((drawing ? (millis() - StartTime) : "0") + " ms", 140, guiHeight - 80);
  
  text("Total rays cast: ", 10, guiHeight - 65);
  text(commas(totalTracedRays + raysThisFrame), 140, guiHeight - 65);
  
  text("Last frame rays: ", 10, guiHeight - 50);
  text(commas(raysLastFrame), 140, guiHeight - 50);
  
  text("Average rays / frame: ", 10, guiHeight - 35);
  text(commas((int)((float)totalTracedRays / max(FrameNum, 1))), 140, guiHeight - 35);
  
  text("Average rays / sec: ", 10, guiHeight - 20);
  text(commas((int)((float)totalTracedRays / max(totalRenderTime/1000, 1))), 140, guiHeight - 20);
  
  text("Rays this frame: ", 10, guiHeight - 5);
  text(commas(raysThisFrame), 140, guiHeight - 5);
}

 public void ImageSettings(){
  fill(0);
  textSize(16);
  textAlign(CENTER);
  text("Image Settings", guiWidth / 2, 18);
  
  textAlign(LEFT);
  textSize(12);
  textLeading(14);
  
  NormBar(bloomStrenBar, "Bloom Strength", bloomStrength, 0, 4, false, new barInter(){public void onChange(float v){
    bloomStrength = max(v, 0);
    bloomToggle = bloomStrength != 0;
    imageUpdated = true;
  }});
  
  bloomSize = round(NormBar(bloomSizeBar, "Bloom Size", bloomSize, 0, 20, true, new barInter(){public void onChange(float v){
    imageUpdated = true;
  }}));
  
  exposure = NormBar(exposureBar, "Exposure", exposure, 0, 2, false, new barInter(){public void onChange(float v){
    imageUpdated = true;
  }});
  
  contrast = NormBar(contrastBar, "Contrast", contrast, -1, 1, false, new barInter(){public void onChange(float v){
    imageUpdated = true;
  }});
}

 public void initalizeBars(){ // extra code to configure scroll bars that will get called only once from the setup function
  bloomStrenBar.setSliderPos(bloomStrength / 4);
  bloomSizeBar.setSliderPos((float)bloomSize / 20);
  exposureBar.setSliderPos(exposure / 2);
  contrastBar.setSliderPos((contrast + 1) / 2);
  cameraFOVBar.setSliderPos(Cam.Fov / PI * 2 * (1.01f) + 0.01f);
  bloomSizeBar.T.intOnly = true;
  cameraResBar.T.intOnly = true;
  tileDivisionsBar.T.intOnly = true;
  cameraResBar.setSliderPos((float)(Res - 1) / 9);
  samplesBar.setSliderPos((float)(samples - 1) / 100);
  cameraPhiBar.setSliderPos((cameraAngle.y / (PI/2 - 0.01f) + 1) / 2);
  scrollArea.maxScroll = 1000;
  
  if(bloomStrength == 0){
    bloomToggle = false;
  }else{
    bloomToggle = true;
  }
}

 public void moveObjects(){
  if(getKey(ESC).released && objectSelected){ // if escape is pressed set selected object to null
    if(objectGrabbed){
      objectGrabbed = false;
      selectedObject.pos = originalPosition;
    }else if(objectRotating){
      objectRotating = false;
      selectedObject.SetRotation(originalAngle);
    }else{
      selectedObject = null;
      objectSelected = false;
    }
    directions = 7;
    preresUpdate = true;
  }
  
  if(objectSelected && !objectGrabbed && getKey('G').released){
    if(objectRotating){
      selectedObject.SetRotation(originalAngle);
      objectRotating = false;
    }
    objectGrabbed = true;
    originalPosition = selectedObject.pos.copy();
    selPos.x = mouseX; selPos.y = mouseY;
    directions = 7;
  }
  
  if(objectSelected && !objectRotating && getKey('R').released){
    if(objectGrabbed){
      selectedObject.pos = originalPosition;
      objectGrabbed = false;
    }
    objectRotating = true;
    originalAngle = selectedObject.Q.copy();
    originalPosition = selectedObject.pos.copy();;
    selPos.x = mouseX; selPos.y = mouseY;
    directions = 7;
  }
  
  if(objectGrabbed){ // object is being translated
    int pdir = directions;
    if(getKey('X').pressed){
      directions = getKey(SHIFT).held ? 6 : 1;
    }else if(getKey('Y').pressed){
      directions = getKey(SHIFT).held ? 5 : 2;
    }else if(getKey('Z').pressed){
      directions = getKey(SHIFT).held ? 3 : 4;
    }
    
    PVector norm;
    if((directions == 1 || directions == 2 || directions == 4)){
      PVector Xdir = new PVector(directions&1, (directions>>1)&1, (directions>>2)&1);
      PVector Ydir = new PVector(0, 0, 1);
      if(directions == 4){Ydir = Cam.b;}
      norm = Xdir.cross(Ydir);
    }else if(directions == 7){
      norm = Cam.t;
    }else{
      int l = 0;
      if(directions == 4){l = 4;}else
      {l = ((directions + 1) % 2) + 1;}
      PVector Xdir = new PVector(l&1, (l&2)/2, (l&4)/4);
      l = directions - l;
      PVector Ydir = new PVector(l&1, (l&2)/2, (l&4)/4);
      
      norm = Xdir.cross(Ydir).normalize();
    }
    PVector rpos = PVector.sub(originalPosition, Cam.Pos);
    PVector rdir = Cam.getRay(mouseX / (float)Res, mouseY / (float)Res);
    
    float d = -rpos.dot(norm) / rdir.dot(norm);
    PVector hpos = PVector.mult(rdir, d).add(rpos);
    multEle(hpos, new PVector(directions&1, (directions>>1)&1, (directions>>2)&1));
    hpos.mult(-1).add(originalPosition);
    selectedObject.pos = hpos;
    preresUpdate = mouseX != pmouseX || mouseY != pmouseY || directions != pdir;
  }
  
  if(objectRotating){
    int pdir = directions;
    if(getKey('X').pressed){
      directions = getKey(SHIFT).held ? 6 : 1;
    }else if(getKey('Y').pressed){
      directions = getKey(SHIFT).held ? 5 : 2;
    }else if(getKey('Z').pressed){
      directions = getKey(SHIFT).held ? 3 : 4;
    }
    PVector axis;
    if(directions == 1 || directions == 2 || directions == 4){
      axis = new PVector(directions&1, (directions>>1)&1, (directions>>2)&1).mult(-1);
      multEle(axis, Sign(Cam.t));
    }else if(directions == 7){
      axis = PVector.mult(Cam.t, -1);
    }else{
      int d = ~directions;
      axis = originalAngle.ApplyTo(new PVector(d&1, (d>>1)&1, (d>>2)&1));
    }
    PVector objectPos = Cam.WorldToScreen(selectedObject.pos);
    
    float angle = atan2(objectPos.y - selPos.y, objectPos.x - selPos.x) - atan2(objectPos.y - mouseY, objectPos.x - mouseX);
    
    Quaternion newQuat = GetRotationAbout(axis, angle);
    newQuat.PostMultiply(originalAngle);
    selectedObject.SetRotation(newQuat);
    preresUpdate = mouseX != pmouseX || mouseY != pmouseY || directions != pdir;
  }
  
  if(getKey(ENTER).held || getKey(RETURN).held){
    objectGrabbed = false;
    objectRotating = false;
    preresUpdate = true;
  }
}

 public void DrawLine(PVector A, PVector B){
  PVector OPos = Cam.WorldToScreen(A);
  PVector X = Cam.WorldToScreen(B);
  PVector dir = PVector.sub(OPos, X).normalize();
  PVector dirP = new PVector(-dir.y, dir.x);
  
  PVector C = PVector.mult(dirP, dirP.dot(X));
  
  float lim = drawWidth + drawHeight;
  float lowExtent = constrain(-C.x / dir.x, -lim, lim);
  float highExtent = constrain((drawWidth - C.x) / dir.x, -lim, lim);
  line(C.x + dir.x * lowExtent, C.y + dir.y * lowExtent, C.x + dir.x * highExtent, C.y + dir.y * highExtent);
}

 public void DrawAxes(){
  if(!objectSelected){return;}
  strokeWeight(1);
  if(directions != 7 && (objectGrabbed || (objectRotating && (directions == 1 || directions == 2 || directions == 4)))){
    if((directions & 1) != 0){
      stroke(255, 0, 0);
      DrawLine(originalPosition, new PVector(1, 0, 0).add(originalPosition));
    }
    if((directions & 2) != 0){
      stroke(0, 255, 0);
      DrawLine(originalPosition, new PVector(0, 1, 0).add(originalPosition));
    }
    if((directions & 4) != 0){
      stroke(0, 0, 255);
      DrawLine(originalPosition, new PVector(0, 0, 1).add(originalPosition));
    }
  }else if(objectRotating){
    if((directions & 1) == 0){
      stroke(255, 0, 0);
      DrawLine(originalPosition, originalAngle.ApplyTo(new PVector(1, 0, 0)).add(originalPosition));
    }
    if((directions & 2) == 0){
      stroke(0, 255, 0);
      DrawLine(originalPosition, originalAngle.ApplyTo(new PVector(0, 1, 0)).add(originalPosition));
    }
    if((directions & 4) == 0){
      stroke(0, 0, 255);
      DrawLine(originalPosition, originalAngle.ApplyTo(new PVector(0, 0, 1)).add(originalPosition));
    }
  }
}
class DrawOverlayCallback { // hacky way to get the overlay for certain gui elements to be drawn last and thus ontop of the other bars
  float offx, offy;
  DrawOverlayCallback(float offx, float offy){
    this.offx = offx;
    this.offy = offy;
  }
   public void Draw(){}
}

class HScrollbar {
  int swidth, sheight;    // width and height of bar
  float xpos, ypos;       // x and y position of bar
  float spos, newspos;    // x position of slider
  float sposMin, sposMax; // max and min values of slider
  boolean over;           // is the mouse over the slider?
  boolean locked;
  float ratio;
  TextBox T;
  String mouseOverText;

  HScrollbar (float xp, float yp, int sw, int sh) {
    Setup(xp, yp, sw, sh, null);
  }
  
  HScrollbar (float xp, float yp, int sw, int sh, String mouseOverText) {
    Setup(xp, yp, sw, sh, mouseOverText);
  }
  
   public void Setup(float xp, float yp, int sw, int sh, String mouseOverText){
    swidth = sw;
    sheight = sh;
    int widthtoheight = sw - sh;
    ratio = (float)sw / (float)widthtoheight;
    xpos = xp;
    ypos = yp-sheight/2;
    spos = xpos + swidth/2 - sheight/2;
    newspos = spos;
    sposMin = xpos;
    sposMax = xpos + swidth - sheight;
    //loose = l;
    
    T = new TextBox(xpos + sw + 5, ypos - 1, 50, sh + 2, 7);
    this.mouseOverText = mouseOverText;
  }

   public void update() {
    over = overEvent();
    if (!pmousePressed && mousePressed && over) {
      locked = true;
    }
    if (!mousePressed) {
      locked = false;
    }
    if (locked) {
      spos = sposMin + constrain(mouseX - screenX(xpos, ypos) - sheight/2, 0, sposMax - sposMin);
    }
    T.update();
  }

   public boolean overEvent() {
    return mouseX > screenX(xpos, ypos) && mouseX < screenX(xpos + swidth, ypos) && mouseY > screenY(xpos, ypos) && mouseY < screenY(xpos, ypos+sheight);
  }

   public void display(String aboveText, String rightText) {
    fill(0);
    textAlign(CENTER, CENTER);
    textSize(12); textLeading(14);
    text(aboveText, (5 + xpos) / 2, ypos + sheight/2 - 2);
    
    // decide whether to display mouse over text
    if(mouseOverText != null && mouseX > screenX(0, ypos) && mouseX < screenX(xpos, ypos) && mouseY > screenY(0, ypos) && mouseY < screenY(xpos, ypos + sheight)){
      float xoff = screenX(0, 0), yoff = screenY(0, 0);
      overlayCallback = new DrawOverlayCallback(xoff, yoff){public void Draw(){
        textSize(12); textLeading(14);
        String toDisplay = breakText(mouseOverText, xpos - 20);
        fill(140);
        noStroke();
        rect(offx + 10, offy + ypos + sheight, xpos - 10, 10 + 14 * numLines(toDisplay));
        
        fill(0);
        textAlign(LEFT, TOP);
        text(toDisplay, offx + 15, offy + 5 + ypos + sheight);
      }};
    }
    
    textAlign(LEFT);
    
    noStroke();
    fill(204);
    rect(xpos, ypos, swidth, sheight);
    if ((over && !mousePressed) || locked) {
      fill(0, 0, 0);
    } else {
      fill(102, 102, 102);
    }
    rect(constrain(round(spos), sposMin, sposMax), round(ypos), sheight, sheight);
    if(!T.selected){
      T.setValue(rightText);
    }
    T.display();
  }

   public float getValue() {
    // Convert spos to be values between
    // 0 and the total width of the scrollbar
    return (spos - xpos) * ratio / swidth;
  }
  
   public void setSliderPos(float value) {
    spos = value * swidth / ratio + xpos;
    newspos = spos;
  }
}

 public float HDiffBar(HScrollbar bar, String txt, float val, float speed){
  return HDiffBar(bar, txt, val, speed, null);
}

 public float HDiffBar(HScrollbar bar, String txt, float val, float speed, barInter b){
  bar.display(txt, nf(val, 0, 0));
  bar.update();
  if(bar.T.selected){
    val = bar.T.getNumValue();
    preresUpdate = true;
    if(b != null){b.onChange(val);}
  }
  if(bar.locked){
    val = val + (bar.getValue() - 0.5f) * speed;
    preresUpdate = true;
    if(b != null){b.onChange(val);}
  }else{
    bar.setSliderPos(0.5f);
  }
  return val;
}

 public float Bar01(HScrollbar bar, String txt, float val){
  bar.setSliderPos(val);
  bar.display(txt, nf(val, 0, 0));
  bar.update();
  if(bar.T.selected){
    val = constrain(bar.T.getNumValue(), 0, 1);
  }
  if(bar.locked){
    val = bar.getValue();
  }
  preresUpdate |= bar.locked || bar.T.selected;
  
  return val;
}

 public float NormBar(HScrollbar bar, String txt, float val, float min, float max, boolean Constrain){
  return NormBar(bar, txt, val, min, max, Constrain, null);
}

 public float NormBar(HScrollbar bar, String txt, float val, float min, float max, boolean Constrain, barInter b){
  float iv = val;
  bar.setSliderPos((val - min) / (max - min));
  bar.display(txt, nf(val, 0, 0));
  bar.update();
  if(bar.T.selected){
    val = bar.T.getNumValue();
    val = Constrain ? constrain(val, min, max) : val;
    if(b != null){b.onPress(val);}
  }
  if(bar.locked){
    val = bar.getValue() * (max - min) + min;
    val = Constrain ? constrain(val, min, max) : val;
    if(b != null){b.onPress(val);}
  }
  val = Constrain ? constrain(val, min, max) : val;
  if(iv != val && b != null && (bar.T.selected || bar.locked)){
    b.onChange(val);
  }
  return val;
}

class barInter {
   public void onChange(float val){};
   public void onPress(float val){};
}

class Button {
  boolean state;
  float xpos, ypos, w, h;
  boolean over, pressed;
  float borderSize;
  String btnText;
  
  Button(float xp, float yp, float w, float h, String txt){
    this.xpos = xp;
    this.ypos = yp;
    this.w = w;
    this.h = h;
    this.state = true;
    btnText = txt;
    
    borderSize = min(w * 0.06f, h * 0.06f);
  }
  
   public void update(){
    over = overEvent();
    if(mousePressed && !pmousePressed && over){
      pressed = true;
    }
    if(pressed && !mousePressed){
      state = !state;
      pressed = false;
    }
  }
  
   public boolean overEvent() {
    if (mouseX > screenX(xpos, ypos) && mouseX < screenX(xpos + w, ypos) &&
       mouseY > screenY(xpos, ypos) && mouseY < screenY(xpos, ypos + h)) {
      return true;
    } else {
      return false;
    }
  }
  
   public void display(){
    noStroke();
    
    fill(150);
    rect(xpos, ypos, w, h, 3);
    
    if(pressed){
      fill(80);
    }else if(state){
      fill(200);
    }else{
      fill(140);
    }
    
    rect(xpos + borderSize, ypos + borderSize, w - borderSize * 2, h - borderSize * 2, 3);
    
    fill(0);
    textAlign(CENTER, CENTER);
    text(btnText, xpos + w/2, ypos + h/2 - 2);
    textAlign(LEFT);
  }
  
   public void setState(boolean newState){
    state = newState;
  }
  
   public boolean getState(){
    return state;
  }
}

IntList keyEvents = new IntList();
class TextBox { // only allows numbers and periods by default because rn I only need it for numbers
  String currentValue;
  float xpos, ypos, w, h;
  int maxLen;
  boolean over, selected;
  int flashTimer = 0;
  int flashLength = 60;
  boolean intOnly = false;
  int cursorPos;
  
  TextBox(float xp, float yp, float w, float h, int maxLen, String defaultVal){
    this.xpos = xp;
    this.ypos = yp;
    this.w = w;
    this.h = h;
    
    if(maxLen > 0){
      this.maxLen = maxLen;
    }else{
      this.maxLen = 100;
    }
    currentValue = defaultVal;
  }
  
  TextBox(float xp, float yp, float w, float h, int maxLen){
    this.xpos = xp;
    this.ypos = yp;
    this.w = w;
    this.h = h;
    
    if(maxLen > 0){
      this.maxLen = maxLen;
    }else{
      this.maxLen = 100;
    }
    currentValue = "0";
  }
  
   public void update(){
    over = overEvent();
    if(mousePressed && !pmousePressed && over && selected){
      flashTimer = flashLength/2;
      int tl = currentValue.length();
      cursorPos = 0;
      for(int i = tl; i >= 0; i--){
        if(mouseX - screenX(xpos+2 + textWidth(currentValue.substring(0, i)), ypos) > 0){
          cursorPos = i;
          
          if(i != tl && abs(mouseX - screenX(xpos+2 + textWidth(currentValue.substring(0, i+1)), ypos)) < abs(mouseX - screenX(xpos+2 + textWidth(currentValue.substring(0, i)), ypos))){
            cursorPos++;
          }
          
          break;
        }
      }
    }
    if(over && mousePressed && !pmousePressed && !selected){
      cursorPos = currentValue.length();
      selected = true;
      flashTimer = flashLength/2;
      keyEvents.clear();
    }
    if(mousePressed && !pmousePressed && !over){
      deselect();
    }
    if(selected){
      flashTimer = (flashTimer + 1) % flashLength;
    }
    
    if(selected){
      for(int e : keyEvents){
        if(e == 8 && currentValue.length() > 0 && cursorPos > 0){
          //currentValue = currentValue.substring(0, currentValue.length() - 1);
          currentValue = currentValue.substring(0, cursorPos - 1) + currentValue.substring(cursorPos, currentValue.length());
          cursorPos--;
        }else if(e >= 48 && e <= 57 && currentValue.length() < maxLen){
          cursorPos++;
          currentValue = currentValue.substring(0, cursorPos-1) + str(e - 48) + currentValue.substring(cursorPos-1, currentValue.length());
        }else if(e == 46 && !currentValue.contains(".") && !intOnly && currentValue.length() < maxLen){
          cursorPos++;
          currentValue = currentValue.substring(0, cursorPos-1) + "." + currentValue.substring(cursorPos-1, currentValue.length());
        }else if(e == 10){
          deselect();
          break;
        }else if(e == 37){
          cursorPos = max(0, cursorPos-1);
        }else if(e == 39){
          cursorPos = min(currentValue.length(), cursorPos+1);
        }else if(e == 38){
          cursorPos = currentValue.length();
        }else if(e == 40){
          cursorPos = 0;
        }else if(e == 45 && cursorPos == 0 && (currentValue.length() == 0 || currentValue.charAt(0) != '-')){
          currentValue = "-" + currentValue;
          cursorPos++;
        }
      }
      keyEvents.clear();
    }
  }
  
   public void deselect(){
    selected = false;
    flashTimer = 0;
    if(currentValue.length() == 0){
      currentValue = "0";
    }
    
    if(currentValue.charAt(currentValue.length()-1) == '.'){
      currentValue = currentValue.substring(0, currentValue.length()-1);
    }
    while(currentValue.length() > 1 && currentValue.charAt(0) == '0' && currentValue.charAt(1) != '.'){
      currentValue = currentValue.substring(1, currentValue.length());
    }
    if(currentValue.length() == 0){
      currentValue = "0";
    }
  }
  
   public void display(){
    textSize(10);
    fill(200);
    stroke((over || selected) ? 0 : 150);
    strokeWeight(1);
    rect(xpos, ypos, w, h);
    
    fill(0);
    textAlign(LEFT, CENTER);
    text(currentValue, xpos + 2, ypos + h/2 - 1);
    if(flashTimer > flashLength/2){
      float cx = xpos + 2 + textWidth(currentValue.substring(0, cursorPos));
      line(cx, ypos + h/2 - g.textSize/2, cx, ypos + h/2 + g.textSize/2);
      //text("|", , );
    }
  }
  
   public boolean overEvent() {
    if (mouseX > screenX(xpos, ypos) && mouseX < screenX(xpos + w, ypos) &&
       mouseY > screenY(xpos, ypos) && mouseY < screenY(xpos, ypos + h)) {
      return true;
    } else {
      return false;
    }
  }
  
   public void setValue(String newVal){
    currentValue = newVal;
  }
  
   public float getNumValue(){
    //String processed = currentValue;
    /*if(processed.charAt(processed.length()-1) == '.'){
      processed = processed.substring(0, processed.length()-1);
    }*/
    if(currentValue.length() == 0 || currentValue.equals(".") || currentValue.equals("-") || currentValue.equals("-.")){
      return 0;
    }
    return PApplet.parseFloat(currentValue);
  }
  
   public String getValue(){
    return currentValue;
  }
}

ArrayList<MouseEvent> scrollEvents = new ArrayList<MouseEvent>();
class ScrollArea {
  float currentScroll, minScroll, maxScroll;
  float xpos, ypos, w, h;
  boolean over;
  VScrollbar bar;
  
  ScrollArea(float xp, float yp, int w, int h){
    xpos = xp;
    ypos = yp;
    this.w = w;
    this.h = h;
    
    minScroll = 0;
    maxScroll = w;
    bar = new VScrollbar(xp, yp, 10, h, 50);
    bar.barSize = h / (maxScroll - minScroll) * bar.sheight;
  }
  
   public void update(){
    over = overEvent();
    if(bar.locked){
      currentScroll = constrain(bar.getValue() * (max(maxScroll - h, 0) - minScroll) + minScroll, minScroll, max(maxScroll - h, 0));
    }else{
      MouseEvent e;
      for(int i = scrollEvents.size()-1; i >= 0; i--){
        e = scrollEvents.get(i);
        if(abs(round(e.getCount())) > 0 && inBox(e.getX(), e.getY())){
          scrollEvents.remove(i);
          currentScroll = constrain(currentScroll + e.getCount(), minScroll, max(maxScroll - h, 0));
        }
      }
      //println((currentScroll - minScroll) / (max(maxScroll - h, 0) - minScroll));
      bar.setSliderPos((currentScroll - minScroll) / (max(maxScroll - h, 0) - minScroll));
    }
    //println(currentScroll, minScroll, max(maxScroll - h, 0));
    if(maxScroll > h){
      bar.barSize = h / (maxScroll - minScroll) * bar.sheight;
      bar.update();
    }
    currentScroll = constrain(currentScroll, minScroll, max(maxScroll - h, 0));
    //println(bar.getValue());
  }
  
   public boolean overEvent() {
    if (mouseX > screenX(xpos, ypos) && mouseX < screenX(xpos + w, ypos) &&
       mouseY > screenY(xpos, ypos) && mouseY < screenY(xpos, ypos + h)) {
      return true;
    } else {
      return false;
    }
  }
  
   public boolean inBox(float X, float Y) {
    if (X > screenX(xpos, ypos) && X < screenX(xpos + w, ypos) &&
       Y > screenY(xpos, ypos) && Y < screenY(xpos, ypos + h)) {
      return true;
    } else {
      return false;
    }
  }
  
   public void display(){
    if(maxScroll > h){
      bar.display();
    }
  }
}

 public void mouseWheel(MouseEvent event) {
  scrollEvents.add(event);
}

class VScrollbar {
  int swidth, sheight;    // width and height of bar
  float xpos, ypos;       // x and y position of bar
  float spos;    // x position of slider
  float sposMin, sposMax; // max and min values of slider
  boolean over;           // is the mouse over the slider?
  boolean locked;
  float ratio;
  float barSize;

  VScrollbar (float xp, float yp, int sw, int sh, float barSize) {
    this.barSize = barSize;
    swidth = sw;
    sheight = sh;
    int widthtoheight = sw - sh;
    ratio = (float)sw / (float)widthtoheight;
    xpos = xp;
    ypos = yp;
    spos = ypos;
    sposMin = ypos;
    sposMax = ypos + sheight - barSize;
  }

   public void update() {
    sposMax = ypos + sheight - barSize;
    over = overEvent();
    if (!pmousePressed && mousePressed && over) {
      locked = true;
    }
    if (!mousePressed) {
      locked = false;
    }
    if (locked) {
      spos = constrain(spos + mouseY - pmouseY, sposMin, sposMax);
    }
  }

   public boolean overEvent() {
    if (mouseX > screenX(xpos, ypos) && mouseX < screenX(xpos + swidth, ypos) &&
       mouseY > screenY(xpos, ypos) && mouseY < screenY(xpos, ypos+sheight)) {
      return true;
    } else {
      return false;
    }
  }

   public void display() {
    noStroke();
    fill(204);
    rect(xpos, ypos, swidth, sheight);
    if ((over && !mousePressed) || locked) {
      fill(0, 0, 0);
    } else {
      fill(102, 102, 102);
    }
    rect(round(xpos), constrain(round(spos), sposMin, sposMax), swidth, barSize);
  }

   public float getValue() {
    // Convert spos to be values between
    // 0 and the total width of the scrollbar
    return (spos - ypos) / (sheight - barSize);
  }
  
   public void setSliderPos(float value) {
    spos = value * (sheight - barSize) + ypos;
  }
}

class CheckBox {
  int xpos, ypos;
  int xoffset;
  boolean enabled = false;
  boolean state = true;
  boolean over;
  String label;
  int size;
  
  CheckBox(int xpos, int ypos, int xoffset, int size, String label){
    this.xpos = xpos;
    this.ypos = ypos;
    this.size = size;
    this.label = label;
    this.xoffset = xoffset;
  }
  
   public void display(){
    textAlign(LEFT, CENTER);
    textSize(12); textLeading(14);
    
    fill(enabled ? 0 : 100);
    
    text(label, xpos, ypos + size / 2 - 2);
    
    pushMatrix();
    translate(xpos + xoffset - size, ypos);
    strokeWeight(1);
    if(enabled){
      fill(150);
      stroke(50);
    }else{
      fill(200);
      stroke(150);
    }
    rect(0, 0, size, size, 5);
    
    if(state){
      strokeWeight(1);
      if(enabled){
        stroke(0);
      }else{
        stroke(100);
      }
      
      line(3, 3, size-3, size-3);
      line(3, size-3, size-3, 3);
    }
    popMatrix();
  }
  
   public void update(){
    if(!enabled){return;}
    updateOver();
    
    state ^= over && !mousePressed && pmousePressed;
  }
  
   public void updateOver(){
    int lx = xpos + xoffset - size;
    over = screenX(lx, ypos) < mouseX && mouseX < screenX(lx + size, ypos + size) && screenY(lx, ypos) < mouseY && mouseY < screenY(lx + size, ypos + size);
  }
  
   public void setEnabled(boolean newEnabled){
    enabled = newEnabled;
  }
  
   public void setState(boolean newState){
    state = newState;
  }
}
 public float Sign(float v){
  if(v >= 0){
    return 1;
  }else{
    return -1;
  }
}

 public PVector Sign(PVector v){
  return new PVector(Sign(v.x), Sign(v.y), Sign(v.z));
}

 public void CopyTo(PVector dst, PVector src){
  dst.x = src.x;
  dst.y = src.y;
  dst.z = src.z;
}

 public String commas(int v){
  String ini = nf(v, 0);
  int inil = ini.length();
  if(inil <= 3){
    return ini;
  }
  
  String out = ini.substring(inil-3, inil);
  
  for(int i = inil-3; i >= inil%3 + 3; i-=3){
    out = ini.substring(i-3, i) + "," + out;
  }
  if(inil%3 == 0){
    return out;
  }else{
    return ini.substring(0, inil%3) + "," + out;
  }
}

 public String commas(long v){
  String ini = String.valueOf(v);
  int inil = ini.length();
  if(inil <= 3){
    return ini;
  }
  
  String out = ini.substring(inil-3, inil);
  
  for(int i = inil-3; i >= inil%3 + 3; i-=3){
    out = ini.substring(i-3, i) + "," + out;
  }
  if(inil%3 == 0){
    return out;
  }else{
    return ini.substring(0, inil%3) + "," + out;
  }
}

 public void transferCords(PVector a, PVector b){
  a.x = b.x;
  a.y = b.y;
  a.z = b.z;
}

 public PVector multEle(PVector a, PVector b){
  a.x *= b.x;
  a.y *= b.y;
  a.z *= b.z;
  return a;
}

 public void loadSettings(){
  preferences = loadTable("preferences.csv", "header");
  
  TableRow row = preferences.getRow(0);
  
  bloomStrength = row.getFloat("bloomStrength");
  bloomSize = row.getInt("bloomSize");
  exposure = row.getFloat("exposure");
  contrast = row.getFloat("contrast");
}

 public void writeSettings(){
  preferences = new Table();
  preferences.addColumn("bloomStrength");
  preferences.addColumn("bloomSize");
  preferences.addColumn("exposure");
  preferences.addColumn("contrast");
  
  TableRow newRow = preferences.addRow();
  newRow.setFloat("bloomStrength", bloomStrength);
  newRow.setInt("bloomSize", bloomSize);
  newRow.setFloat("exposure", exposure);
  newRow.setFloat("contrast", contrast);
  
  saveTable(preferences, "data/preferences.csv");
}

 public float rFloat(int x){
  x *= 100;
  x += ( x << 10 );
  x ^= ( x >>  6 );
  x += ( x <<  3 );
  x ^= ( x >> 11 );
  x += ( x << 15 );
  return (float)abs(x) / 2147483647;
}

 public PVector orthVector(PVector n){
  PVector v = PVector.random3D();
  while(v.dot(n) == 0){
    v = PVector.random3D();
  }
  return n.cross(v).normalize();
}

 public String breakText(String input, float boxWidth){ // adds new line characters to an input string, breaks only on spaces
  char[] chars = input.toCharArray();
  
  float currentWidth = 0;
  float wordWidth;
  float spaceWidth = textWidth(' ');
  
  String output = "";
  int wordStart = 0;
  int w;
  String word;
  while(wordStart < chars.length){
    w = wordStart;
    while(w < chars.length && chars[w] != ' ' && chars[w] != '\n'){w++;} // finds next space
    word = (String)input.subSequence(wordStart, w);
    wordWidth = textWidth(word);
    
    if(w < chars.length && chars[w] == '\n'){ // keep \n s in the word
      output += "\n" + word;
      currentWidth = wordWidth;
      wordStart = w+1;
      continue;
    }
    
    if(currentWidth + spaceWidth + wordWidth > boxWidth){ // if adding a word to this line makes it too long then insert a newline
      output += '\n';
      currentWidth = wordWidth;
    }else{ // no need to add a new line yet, just add a space to seperate chars
      if(wordStart > 0){output += ' ';}
      currentWidth += spaceWidth + wordWidth;
    }
    
    output += word;
    wordStart = w+1;
  }
  
  return output;
}

 public int numLines(String s){ // counts the number of lines that a string will have when printed (based on number of '\n')
  int out = 1;
  for(int i = 0; i < s.length(); i++){
    if(s.charAt(i) == '\n'){
      out++;
    }
  }
  return out;
}

 public void SaveImage(File location){
  if(location == null){return;}
  /*String name = "saves/SavedImage";
  boolean exists = false;
  int add = 1;
  
  File f = dataFile(name + ".png");
  exists = f.isFile();
  
  while(exists){
    exists = dataFile(name + str(++add) + ".png").isFile();
  }*/
  PImage local = imgToSave;
  imgToSave = null;
  
  /*if(!location.isFile()){
    println("Location is not a file");
    return;
  }*/
  
  String extention = location.getAbsolutePath();
  if(extention.contains(".")){
    //String t = "";
    for(int i = 0; i < extention.length(); i++){
      if(extention.charAt(i) == '.'){
        extention = extention.substring(i + 1,extention.length());
        break;
      }
    }
  }else{
    extention = "tiff";
    location = new File(location.getAbsolutePath() + "." + extention);
    
    println(location);
  }
  
  /*if(!location.exists()){
    try{
      location.createNewFile();
    }catch(IOException e){
      println("Unable to create file at this location");
      return;
    }
  }*/
  
  String dir = location.getPath();
  local.save(dir);
  
  /*if(!location.canWrite()){
    println("Cannot write to this location");
  }
  println(location.getAbsolutePath());
  try {
    imgToSave.save(location.getAbsolutePath());
  }catch(Exception e){
    println("failed to save");
  }*/
}

 public ObjParts ReadOBJ(String fileName){
  BufferedReader reader = createReader(fileName);
  
  ArrayList<PVector> vertices = new ArrayList<PVector>();
  IntList faces = new IntList();
  
  ArrayList<PVector> vertexNormals = new ArrayList<PVector>();
  IntList vnIndices = new IntList();
  
  ArrayList<UV> vertUVs = new ArrayList<UV>();
  IntList uvInds = new IntList();
  
  try {
    String line = reader.readLine();
    while(line != null){
      String[] parts = line.split(" ");
      if(parts[0].equals("v")){ // vertex
        vertices.add(new PVector(Float.parseFloat(parts[1]), Float.parseFloat(parts[2]), Float.parseFloat(parts[3])));
      }else if(parts[0].equals("vn")){ // vertex normal
        vertexNormals.add(new PVector(Float.parseFloat(parts[1]), Float.parseFloat(parts[2]), Float.parseFloat(parts[3])));
      }else if(parts[0].equals("vt")){ // vertex uv
        vertUVs.add(new UV(Float.parseFloat(parts[1]), Float.parseFloat(parts[2])));
      }else if(parts[0].equals("f")){ // face
        //int[] f = new int[3];
        for(int i = 0; i < 3; i++){
          String[] inds = parts[i+1].split("/");
          faces.append(Integer.parseInt(inds[0]) - 1);
          
          if(inds.length > 1 && inds[1].length() > 0){
            try{
              uvInds.append(Integer.parseInt(inds[1]) - 1);
            } catch(NumberFormatException e){};
          }
          
          if(inds.length > 2 && inds[2].length() > 0){
            try{
              vnIndices.append(Integer.parseInt(inds[2]) - 1);
            } catch(NumberFormatException e){};
          }
        }
        //faces.add(f);
      }
      
      line = reader.readLine();
    }
  } catch(IOException e){
    e.printStackTrace();
  }
  
  UV[] uvArr = vertUVs.toArray(new UV[vertUVs.size()]);
  int[] uvIndArr = uvInds.toArray();
  
  if(uvArr.length == 0){
    uvArr = null;
    uvIndArr = null;
  }
  
  PVector[] vnArr = vertexNormals.toArray(new PVector[vertexNormals.size()]);
  int[] vnIndArr = vnIndices.toArray();
  
  if(vnArr.length == 0){
    vnArr = null;
    vnIndArr = null;
  }
  
  return new ObjParts(vertices.toArray(new PVector[0]), faces.toArray(),
                      vnArr, vnIndArr,
                      uvArr, uvIndArr);
}

class ObjParts {
  PVector[] verts;
  int[] faces;
  
  PVector[] vertNorms;
  int[] vnInds;
  
  UV[] vertUVs;
  int[] uvInds;
  ObjParts(PVector[] verts, int[] faces, PVector[] vertNorms, int[] vnInds, UV[] vertUVs, int[] uvInds){
    this.verts = verts;
    this.faces = faces;
    this.vertNorms = vertNorms;
    this.vnInds = vnInds;
    this.vertUVs = vertUVs;
    this.uvInds = uvInds;
  }
}

AtomicBoolean selectingObject = new AtomicBoolean(false);

 public void loadObjectGUI(File location){
  if(location == null || !location.exists() || !location.canRead() || !location.isFile()){
    return;
  }
  
  String name = location.getName();
  println(name.substring(name.length() - 3, name.length()));
  if(!name.substring(name.length() - 3, name.length()).equals("obj")){ // file extention is not obj
    return;
  }
  
  Mesh mesh = new Mesh(new PVector(0, 0, 0), location.getAbsolutePath(), true, true, new Diffuse(new Color(1, 1, 1)));
  
  if(mesh.verts.length == 0){ // mesh has no vertices, delete
    return;
  }
  
  Objs.add(mesh);
  
  selectedObject = Objs.get(Objs.size() - 1);
  objectSelected = true;
  preresUpdate = true;
  
  selectingObject.set(false);
}



class KDTree { // this implementation is adapted from / inspired by the implementation in PBR-book
  PVector TL, BR;
  Primitive[] objs;
  int[] primSets;
  Node[] nodes;
  int threshold = 8;
  int maxDepth = -1;
  PVector[] Sdirs = {new PVector(1, 0, 0), new PVector(0, 1, 0), new PVector(0, 0, 1)};
  
  float traverseCost = 1;
  float intersectCost = 80;
  float emptyBonus = 0.2f;
  AtomicInteger numThreads = new AtomicInteger();
    
  KDTree(ArrayList<Primitive> objs_){
    objs = objs_.toArray(new Primitive[objs_.size()]);
    Init();
  }
  
  KDTree(Primitive[] objs_){
    objs = objs_;
    Init();
    println("num Nodes: " + nodes.length + " ; primSetSize: " + primSets.length);
  }
  
   public void Init(){
    if(objs.length == 0){return;}
    
    AABB[] BBoxes = new AABB[objs.length];
    BBoxes[0] = new AABB();
    objs[0].getBoundingBox(BBoxes[0].TL, BBoxes[0].BR);
    
    TL = BBoxes[0].TL.copy();
    BR = BBoxes[0].BR.copy();
    AABB t = new AABB(TL, BR);
    for(int i = 1; i < objs.length; i++){
      BBoxes[i] = new AABB();
      objs[i].getBoundingBox(BBoxes[i].TL, BBoxes[i].BR);
      t.grow(BBoxes[i]);
    }
    
    if(maxDepth <= 0){
      maxDepth = round(8 + 1.3f * log(objs.length) / log(2));
    }
    
    IntList pset = new IntList();
    ArrayList<Node> nodes = new ArrayList<Node>();
    IntList startList = new IntList(objs.length);
    for(int i = 0; i < objs.length; i++){startList.append(i);}
    
    Divide(pset, nodes, startList, t, BBoxes, maxDepth, new IntegerW());
    
    this.nodes = nodes.toArray(new Node[nodes.size()]);
    primSets = pset.toArray();
  }
  
   public void Divide(IntList pset, ArrayList<Node> nodes, IntList contained, AABB selfBounds, AABB[] BBoxes, int depth, IntegerW overlapable){
    //AABB selfBounds = getBounds(contained, BBoxes);
    if(0 == depth || contained.size() < threshold){ // can't make internal node so make leaf
      makeLeafNode(pset, nodes, contained, overlapable);
      return;
    }
    // try making an internal node
    
    int n = contained.size();
    //AABB selfBounds = getBounds(contained, BBoxes);
    int splitDir = getSplitDirection(selfBounds);
    PVector sdV = null;
    int chosenLocation = -1;
    int tries = 0;
    float splitPos = 0;
    Edge[] Es = new Edge[n * 2];
    
    PVector S = PVector.sub(selfBounds.BR, selfBounds.TL); // size of bounding box
    float totalSA = 2 * (S.x * S.y + S.x * S.z + S.y * S.z);
    //float InvTotalSA = 1 / totalSA;
    float oldCost = intersectCost * n * totalSA / intersectCost;
    float traC = traverseCost * totalSA / intersectCost / 2;
    
    do {
      sdV = getSplitVector(splitDir);
      
      for(int i = 0; i < n; i++){
        int p = contained.get(i);
        Es[i<<1] = new Edge(BBoxes[p].TL.dot(sdV), false, p);
        Es[1 + (i<<1)] = new Edge(BBoxes[p].BR.dot(sdV), true, p);
      }
      Arrays.sort(Es);
      int above = n;
      int split = 0;
      int below = 0;
      
      float min = sdV.dot(selfBounds.TL);
      float max = sdV.dot(selfBounds.BR);
      float bestC = MAX_FLOAT;

      float oA0Size = S.dot(Sdirs[(splitDir + 1) % 3]);
      float oA1Size = S.dot(Sdirs[(splitDir + 2) % 3]);
      float CapArea = oA0Size * oA1Size;
      float eB = emptyBonus;
      
      for(int i = 0; i < Es.length; i++){
        if(Es[i].end){
          above--;
          split--;
          eB = above == 0 ? emptyBonus : 0;
        }
        
        if(min < Es[i].pos && Es[i].pos < max && split < n){
          float belowP = CapArea + (Es[i].pos - min) * (oA0Size + oA1Size);
          float aboveP = CapArea + (max - Es[i].pos) * (oA0Size + oA1Size);
          //float eB = (above == 0 || below == 0) ? emptyBonus : 0;

          float cost = traC + (1 - eB) * (belowP * below + aboveP * above);
          if(cost < bestC && cost < oldCost){
            splitPos = Es[i].pos;
            bestC = cost;
            chosenLocation = i;
          }
        }
        
        if(!Es[i].end){
          below++;
          split++;
          eB = 0;
        }
      }

      if(0 <= chosenLocation){
        break;
      }
      splitDir = (++splitDir % 3);
    }while(++tries < 3);
    if(tries == 3){ // failed to make internal node, make leaf node instead
      makeLeafNode(pset, nodes, contained, overlapable);
      return;
    }
    
    IntList low = new IntList();
    for(int i = 0; i < chosenLocation; i++){
      if(!Es[i].end){
        low.append(Es[i].prim);
      }
    }
    IntList high = new IntList();
    for(int i = chosenLocation + 1; i < n * 2; i++){
      if(Es[i].end){
        high.append(Es[i].prim);
      }
    }
    Internal nd = new Internal(splitPos, splitDir);
    nodes.add(nd);
    
    AABB lowBox = selfBounds.copy();
    lowBox.BR.add(PVector.mult(sdV, splitPos - lowBox.BR.dot(sdV))); // sets br to splitpos in the direciton of the split
    AABB highBox = selfBounds.copy();
    highBox.TL.add(PVector.mult(sdV, splitPos - highBox.TL.dot(sdV))); // sets tl to splitpos in the direciton of the split
    
    // spawn thread if this split is fairly high in the tree, the sides are roughly balanced (so build time is roughly equivilent), and num threads < 8
    if(maxDepth / 2 <= depth && high.size() / (float)(low.size() + high.size()) > 0.4f && numThreads.get() < 8){
      numThreads.getAndIncrement();
      
      DivideThread dThread = new DivideThread(high, highBox, BBoxes, depth - 1);
      dThread.start();
      // divide low
      Divide(pset, nodes, low, lowBox, BBoxes, depth - 1, overlapable);
      nd.setHighChild(nodes.size()); // set to size and not size-1 because the NEXT node to be added will be the high child
      // divide high
      try{
        dThread.join();
      }catch (Exception e){
        e.printStackTrace();
      }
      
      dThread.Merge(pset, nodes);
    }else{
      // divide low
      Divide(pset, nodes, low, lowBox, BBoxes, depth - 1, overlapable);
      nd.setHighChild(nodes.size()); // set to size and not size-1 because the NEXT node to be added will be the high child
      // divide high
      Divide(pset, nodes, high, highBox, BBoxes, depth - 1, overlapable);
    }
    //516255 ; primSetSize: 988860
  }
  
  class DivideThread extends Thread {
    IntList subPset, contained;
    ArrayList<Node> subNodes;
    AABB selfBounds;
    AABB[] BBoxes;
    int depth;
    
    DivideThread(IntList contained, AABB selfBounds, AABB[] BBoxes, int depth){
      subPset = new IntList();
      subNodes = new ArrayList<Node>();
      this.contained = contained;
      this.selfBounds = selfBounds;
      this.BBoxes = BBoxes;
      this.depth = depth;
    }
    
    public void run(){
      Divide(subPset, subNodes, contained, selfBounds, BBoxes, depth, new IntegerW());
      numThreads.getAndDecrement();
    }
    
     public void Merge(IntList pset, ArrayList<Node> nodes){
      int Noffset = nodes.size();
      int Poffset = pset.size();
      for(Node N : subNodes){
        if(N.isLeaf()){
          Leaf L = (Leaf)N;
          if(1 < L.getNumPrims()){
            L.offset += Poffset;
          }
        }else{
          ((Internal)N).setHighChild(((Internal)N).highChild() + Noffset);
        }
      }
      pset.append(subPset);
      nodes.addAll(subNodes);
    }
  }
  
   public void makeLeafNode(IntList pset, ArrayList<Node> nodes, IntList contained, IntegerW overlapable){ // it is fine to change contained as it is specific to this node
    if(contained.size() == 0){
      nodes.add(new Leaf(0, 0));
    }else if(contained.size() == 1){
      nodes.add(new Leaf(contained.get(0), 1));
    }else{
      /*int cl = contained.size();
      int offset = 0;
      for(int i = pset.size() - 1; i >= 0; i--){
        if(contained.removeValue(pset.get(i)) == -1){
          break;
        }
        offset++;
      }*/
      IntList psE = pset.getSubset(pset.size() - overlapable.get());
      psE.sort();
      contained.sort();
      IntList overlap = new IntList();
      IntList left = new IntList();
      IntList right = new IntList();
      int I = 0;
      int J = 0;
      while(I != psE.size() && J != contained.size()){
        if(psE.get(I) == contained.get(J)){
          overlap.append(psE.get(I));
          I++;
          J++;
        }else if(psE.get(I) < contained.get(J)){
          left.append(psE.get(I++));
        }else{
          right.append(contained.get(J++));
        }
      }
      if(I != psE.size()){
        for(;I < psE.size(); I++){left.append(psE.get(I));}
      }else if(J != contained.size()){
        for(;J < contained.size(); J++){right.append(contained.get(J));}
      }
      
      int rpos = pset.size() - overlapable.get();
      for(int i = overlapable.get() - 1; i >= 0; i--){
        pset.remove(rpos);
      }
      pset.append(left);
      nodes.add(new Leaf(pset.size(), contained.size()));
      pset.append(overlap);
      pset.append(right);
      overlapable.set(right.size());
      //nodes.add(new Leaf(pset.size(), contained.size()));
      //pset.append(contained);
    }
  }
  
   public int getSplitDirection(AABB aabb){
    PVector sz = PVector.sub(aabb.BR, aabb.TL);
    if(sz.x > sz.y && sz.x > sz.z){ // x is biggest
      return 0;
    }else if(sz.y > sz.z){ // y is biggest
      return 1;
    }
    return 2; // z is biggest
  }
  
   public PVector getSplitVector(int sd){
    return Sdirs[sd].copy();
  }
  
   public boolean Trace(Ray r, Hit h){
    PVector inv_dir = new PVector((r.dir.x == 0) ? MAX_FLOAT : 1 / r.dir.x, (r.dir.y == 0) ? MAX_FLOAT : 1 / r.dir.y, (r.dir.z == 0) ? MAX_FLOAT : 1 / r.dir.z);
    
    float near = MAX_FLOAT;
    float far = 0;
    PVector[] Bds = {multEle(PVector.sub(TL, r.pos), inv_dir), multEle(PVector.sub(BR, r.pos), inv_dir)};
    
    float t = 0;
    for(int i = 0; i < 2; i++){
      if(TL.y <= (t = Bds[i].x * r.dir.y + r.pos.y) && t <= BR.y &&
         TL.z <= (t = Bds[i].x * r.dir.z + r.pos.z) && t <= BR.z){near = min(near, Bds[i].x); far = max(far, Bds[i].x);}
      if(TL.x <= (t = Bds[i].y * r.dir.x + r.pos.x) && t <= BR.x &&
         TL.z <= (t = Bds[i].y * r.dir.z + r.pos.z) && t <= BR.z){near = min(near, Bds[i].y); far = max(far, Bds[i].y);}
      if(TL.x <= (t = Bds[i].z * r.dir.x + r.pos.x) && t <= BR.x &&
         TL.y <= (t = Bds[i].z * r.dir.y + r.pos.y) && t <= BR.y){near = min(near, Bds[i].z); far = max(far, Bds[i].z);}
    }
    
    if(near < 0 || (TL.x <= r.pos.x && r.pos.x <= BR.x && TL.y <= r.pos.y && r.pos.y <= BR.y && TL.z <= r.pos.z && r.pos.z <= BR.z)){ // point is inside tree
      near = 0;
    }
    far = min(h.dist, far);
    
    if(near == MAX_FLOAT){return false;}
    
    ToDo[] stack = new ToDo[maxDepth + 1];
    int stackPos = 1;
    stack[0] = new ToDo(near, far, 0);
    boolean out = false;
    while(stackPos > 0){
      ToDo cur = stack[--stackPos];
      
      if(far <= cur.tmin){continue;} // near side of node is further than current far clip plane, so cull node
      if(nodes[cur.node].isLeaf()){ // reached leaf node, check intersection will contents and then continue
        if( ((Leaf)nodes[cur.node]).Trace(r, h) ){
          out = true;
          far = min(far, h.dist); // adjust far plane if hit dist decreases
        }
        continue;
      }
      
      Internal N = (Internal)nodes[cur.node];
      PVector sdV = getSplitVector(N.getSplitDir());
      float rd = r.dir.dot(sdV);
      if(rd == 0){ // ray is parallel to split axis
        stack[stackPos++] = new ToDo(cur.tmin, cur.tmax, 
              N.splitPos < r.pos.dot(sdV) ? N.highChild() : (cur.node + 1)); // pick which node to add to stack
        continue;
      }
      
      float tsplit = (N.splitPos - r.pos.dot(sdV)) * inv_dir.dot(sdV);
      int closeN = 0 < rd ? (cur.node + 1) :  N.highChild();
      int farN   = 0 < rd ?  N.highChild() : (cur.node + 1);
      
      //println(cur.tmin, tsplit, cur.tmax);
      if(cur.tmin <= tsplit && tsplit <= cur.tmax){ // ray passes through both sections
        // recurse with close section taking tmin and far section taking tmax
        stack[stackPos++] = new ToDo(tsplit, cur.tmax, farN); // add far to the stack first so it gets processsed later
        stack[stackPos++] = new ToDo(cur.tmin, tsplit, closeN);
      }else if(cur.tmax < tsplit){ // ray only intersects the close section
        stack[stackPos++] = new ToDo(cur.tmin, cur.tmax, closeN);
      }else if(tsplit < cur.tmin){ // ray only intersects the far section
        stack[stackPos++] = new ToDo(cur.tmin, cur.tmax, farN);
      }
    }
    return out;
  }
  
  private class ToDo {
    float tmin, tmax;
    int node;
    ToDo(float tmin, float tmax, int node){
      this.tmin = tmin;
      this.tmax = tmax;
      this.node = node;
    }
  }
  
  private class IntegerW {
    int v;
    IntegerW(int v){this.v = v;}
    IntegerW(){v = 0;}
     public void set(int v){this.v = v;}
     public int get(){return v;}
  }
  
  private class Node {
    int dataFlags;
     public boolean isLeaf(){
      return (dataFlags & 3) == 3;
    }
  }
  
  private class Internal extends Node{
    float splitPos;
    Internal(float splitPos, int splitDir){
      this.splitPos = splitPos;
      dataFlags = splitDir;
    }
    
     public int getSplitDir(){
      return dataFlags & 3;
    }

     public int highChild(){
      return dataFlags >> 2;
    }
    
     public void setHighChild(int pos){
      dataFlags = (dataFlags & 3) | (pos << 2);
    }
  }
  
  private class Leaf extends Node{
    int offset;
    Leaf(int offset, int numPrims){
      this.offset = offset;
      dataFlags = (numPrims << 2) | 3;
    }
    
     public int getNumPrims(){
      return dataFlags >> 2;
    }
    
     public boolean Trace(Ray r, Hit h){
      int n = getNumPrims();
      if(n == 0){return false;}
      if(n == 1){
        return objs[offset].Trace(r, h);
      }
      
      boolean out = false;

      for(int i = offset + n - 1; i >= offset; i--){
        out |= objs[primSets[i]].Trace(r, h);
      }
      return out;
    }
  }
  
  private class Edge implements Comparable<Edge> {
    boolean end;
    float pos;
    int prim;
    public int compareTo(Edge that){
      float r = that.pos - pos;
      if(r < 0){ // that.pos < this.pos
        return 1;
      }else if(0 < r){ // this.pos < that.pos
        return -1;
      }else if(end != that.end){ // this.pos == that.pos
        return (end && !that.end) ? -1 : 1; // object that that is an end is ordered first
      }else if(prim != that.prim){
        return (prim < that.prim) ? -1 : 1; // return object with the smaller index
      }
      return 0;
    }
    
    Edge(float pos, boolean end, int prim){
      this.pos = pos;
      this.end = end;
      this.prim = prim;
    }
  }
  
  private class AABB {
    PVector TL, BR;
    AABB(PVector TL, PVector BR){
      this.TL = TL;
      this.BR = BR;
    }
    
    AABB(){
      TL = new PVector();
      BR = new PVector();
    }
    
     public void grow(AABB aabb){
      TL.x = min(TL.x, aabb.TL.x); BR.x = max(BR.x, aabb.BR.x);
      TL.y = min(TL.y, aabb.TL.y); BR.y = max(BR.y, aabb.BR.y);
      TL.z = min(TL.z, aabb.TL.z); BR.z = max(BR.z, aabb.BR.z);
    }
    
     public AABB copy(){
      return new AABB(TL.copy(), BR.copy());
    }
  }
}

interface Primitive {
  void getBoundingBox(PVector TL, PVector BR);
  boolean Trace(Ray r, Hit h);
}
class Key {
  int code;
  boolean held;
  boolean pressed, released;
  boolean pressed_buffer, released_buffer;
  int holdDuration = 0;
  
  Key(int code){
    this.code = code;
  }
  
   public void startFrameUpdate(){
    pressed = pressed_buffer;
    pressed_buffer = false;
    released = released_buffer; // if button is not being held then this buffered released is faux
    released_buffer = false;
    
    if(pressed){
      held = true;
      holdDuration = 0;
    }
  }
  
   public void endFrameUpdate(){
    if(released){
      held = false;
    }
    
    pressed = false;
    released = false;
    
    if(held){
      holdDuration++;
    }
  }
}

 public void keyboardStartFrame(){
  if(!focused){ // stops the program from thinking keys are held after clicking out of program
    for(int i : trackedKeys){
      keyState.get(i).released_buffer = true;
    }
  }
  
  for(int k : trackedKeys){
    keyState.get(k).startFrameUpdate();
  }
}

 public void keyboardEndFrame(){
  for(int k : trackedKeys){
    keyState.get(k).endFrameUpdate();
  }
}

 public Key getKey(int code){
  return keyState.get(code);
}

//HashMap<Integer, Boolean> heldKeys = new HashMap<Integer, Boolean>();
HashMap<Integer, Key> keyState = new HashMap<Integer, Key>();
int[] trackedKeys = {'W', 'A', 'S', 'D', SHIFT, ' ', ESC, ENTER, RETURN, 'G', 'R', 'X', 'Y', 'Z', CONTROL};

 public void setupKeys(){
  for(int k : trackedKeys){
    keyState.put(k, new Key(k));
  }
}

 public void keyPressed(){
  if(keyState.containsKey(keyCode)){
    //heldKeys.put(keyCode, true);
    keyState.get(keyCode).pressed_buffer = true;
  }
  
  if(keyCode == ESC){ // stop escape from quitting the program
    key = 0;
  }
}

 public void keyReleased(){
  keyEvents.append(keyCode);
  
  if(keyState.containsKey(keyCode)){
    keyState.get(keyCode).released_buffer = true;
  }
}
interface Material {
  int getType(); // 0 = emissive, 1 = diffuse, 2 = glossy, 3 = transparent, 4 = metal, 5 = texture / diffuse
  
  float getGuiSize();
  void drawGui();
  String getTypeName();
}

HScrollbar RBar = new HScrollbar(120, 0, 120, 12); // used for all colors to save bars
HScrollbar GBar = new HScrollbar(120, 20, 120, 12);
HScrollbar BBar = new HScrollbar(120, 40, 120, 12);

HScrollbar StrengthBar = new HScrollbar(120, 60, 120, 12);

class Emissive implements Material {
  Color c;
  float strength;
  
  Emissive(Color c, float strength){
    this.c = c;
    this.strength = strength;
  }
  
   public int getType(){
    return 0;
  }
  
   public void drawGui(){
    RBar.mouseOverText = "Red part of the light that is emitted";
    GBar.mouseOverText = "Green part of the light that is emitted";
    BBar.mouseOverText = "Blue part of the light that is emitted";
    drawColorBars(c, "Red", "Green", "Blue");
    
    StrengthBar.mouseOverText = "Strength of the light that is emitted";
    NormBar(StrengthBar, "Strength", strength, 0, 20, false, new barInter(){public void onChange(float v){
      strength = max(v, 0);
      preresUpdate = true;
    }});
  }
  
   public float getGuiSize(){
    return 80;
  }
  
   public String getTypeName(){
    return "Emissive";
  }
}

class Diffuse implements Material {
  Color albedo;
  
  Diffuse(Color albedo){
    this.albedo = albedo;
  }
  
  Diffuse(){
    albedo = new Color(0);
  }
  
   public int getType(){
    return 1;
  }
  
   public void drawGui(){
    RBar.mouseOverText = "Amount of red light that's absorbed";
    GBar.mouseOverText = "Amount of green light that's absorbed";
    BBar.mouseOverText = "Amount of blue light that's absorbed";
    drawColorBars(albedo, "Red Albedo", "Green Albedo", "Blue Albedo");
  }
  
   public Color getAlbedo(UV uv){
    return albedo.copy();
  }
  
   public float getGuiSize(){
    return 60;
  }
  
   public String getTypeName(){
    return "Diffuse";
  }
}

class Glossy implements Material {
  Color albedo;
  float roughness;
  
  Glossy(Color albedo, float roughness){
    this.albedo = albedo;
    this.roughness = roughness;
  }
  
   public int getType(){
    return 2;
  }
  
   public void drawGui(){
    RBar.mouseOverText = "Amount of red light that's absorbed";
    GBar.mouseOverText = "Amount of green light that's absorbed";
    BBar.mouseOverText = "Amount of blue light that's absorbed";
    drawColorBars(albedo, "Red Albedo", "Green Albedo", "Blue Albedo");
    
    StrengthBar.mouseOverText = "Amount of light thats being scattered off of a pure reflection";
    roughness = Bar01(StrengthBar, "Roughness", roughness);
  }
  
   public float getGuiSize(){
    return 80;
  }
  
   public String getTypeName(){
    return "Glossy";
  }
}

HScrollbar IORBar = new HScrollbar(120, 80, 120, 12, "Index of refraction of the material");
class Transparent implements Material {
  float ior;
  Color absorbance; // percentage of each type of light that is allowed to pass through (1 means all passes, 0 means none passes)
  float absorbanceStrength; // multiplier for amount of light absorbed (multiplied by distance to get final value)
  float roughness;
  
  Transparent(float ior, Color absorb, float absorbStren, float roughness){
    this.ior = ior;
    absorbance = absorb;
    absorbanceStrength = absorbStren;
    this.roughness = roughness;
  }
  
   public int getType(){
    return 3;
  }
  
   public void drawGui(){
    RBar.mouseOverText = "Amount of red light that's transmitted";
    GBar.mouseOverText = "Amount of green light that's transmitted";
    BBar.mouseOverText = "Amount of blue light that's transmitted";
    drawColorBars(absorbance, "R Transmittance", "G Transmittance", "B Transmittance");
    
    StrengthBar.mouseOverText = "Proportion of light thats transmitted per cm of material";
    NormBar(StrengthBar, "Strength", absorbanceStrength * 10, 0, 2, false, new barInter(){public void onChange(float v){
      absorbanceStrength = max(v/10, 0);
      preresUpdate = true;
    }});
    
    NormBar(IORBar, "IOR", ior, 0, 3, false, new barInter(){public void onChange(float v){
      ior = max(v, 0);
      preresUpdate = true;
    }});
  }
  
   public float getGuiSize(){
    return 100;
  }
  
   public String getTypeName(){
    return "Transparent";
  }
}

class Metal implements Material {
  Color col;
  
  Metal(Color col){
    this.col = col;
  }
  
   public int getType(){
    return 4;
  }
  
   public void drawGui(){
    RBar.mouseOverText = "Amount of red light that's absorbed";
    GBar.mouseOverText = "Amount of green light that's absorbed";
    BBar.mouseOverText = "Amount of blue light that's absorbed";
    drawColorBars(col, "Red", "Green", "Blue");
  }
  
   public float getGuiSize(){
    return 60;
  }
  
   public String getTypeName(){
    return "Metal";
  }
}

Texture textureToSet;
Button setTextureButton = new Button(50, 0, 200, 30, "Select Texture");
class Texture extends Diffuse implements Material {
  PImage img;
  
  Texture(){
    //img = 
  }
  
  Texture(String fileName){
    img = loadImage(fileName);
    img.loadPixels();
  }
    
   public int getType(){
    return 5;
  }
  
   public Color getAlbedo(UV uv){
    if(img == null || uv.u < 0 || uv.v < 0){
      return new Color(0);
    }
    float y = constrain(round((1 - uv.v) * img.height), 0, img.height - 1);
    return toColor(img.pixels[round((y + constrain(uv.u, 0, 1)) * img.width)]);
  }
  
   public void drawGui(){
    setTextureButton.display();
    setTextureButton.update();
    if(!setTextureButton.state){
      setTextureButton.state = true;
      textureToSet = this;
      selectInput("Select texture:", "setImage");
    }
  }
  
   public void setImage(File newImg){
    if(newImg == null){return;}
    img = loadImage(newImg.getAbsolutePath());
    img.loadPixels();
    preresUpdate = true;
  }
  
   public float getGuiSize(){
    return 60;
  }
  
   public String getTypeName(){
    return "Texture";
  }
}

 public void setImage(File newImg){
  textureToSet.setImage(newImg);
}

 public void drawColorBars(Color c, String RedText, String GreenText, String BlueText){
  c.r = Bar01(RBar, RedText, c.r);
  c.g = Bar01(GBar, GreenText, c.g);
  c.b = Bar01(BBar, BlueText, c.b);
}
HScrollbar RxBar = new HScrollbar(120, 10, 120, 12, "Rotation about axis");
HScrollbar RyBar = new HScrollbar(120, 30, 120, 12, "Vertical rotation");
HScrollbar RzBar = new HScrollbar(120, 50, 120, 12, "Horizontal rotation");

abstract class Object{
  Material mat;
  PVector pos;
  boolean invertNormals = false;
  Quaternion Q = new Quaternion(1, 0, 0, 0);
  PVector[] basisMatrix = new PVector[]{new PVector(1, 0, 0), new PVector(0, 1, 0), new PVector(0, 0, 1)};
  PVector scale = new PVector(1, 1, 1);
  PVector invScale = new PVector(1, 1, 1);
  
  Object(PVector pos, Material mat){
    this.mat = mat;
    this.pos = pos;
  }
  
  //boolean testIntersection(Ray r);
   public abstract boolean Trace(Ray r, Hit h);
   public abstract void drawGui();
   public abstract float getGuiSize();
   public abstract PVector getUVCords(PVector hpos);
  
   public Material getMaterial(){
    return mat;
  }
  
   public void setMaterial(Material m){
    mat = m;
  }
  
   public void DrawRotationGUI(float offset){ // convert quaternion to roll, pitch, yaw then back...peak efficiency
    translate(0, offset);
    float oroll = (atan2(2 * (Q.w * Q.i + Q.j * Q.k), 1 - 2 *(Q.i * Q.i + Q.j * Q.j)) + TAU) % TAU;
    float opitch = asin(2 * (Q.w * Q.j - Q.i * Q.k));
    float oyaw = (atan2(2 * (Q.w * Q.k + Q.i * Q.j), 1 - 2 *(Q.j * Q.j + Q.k * Q.k)) + TAU) % TAU;
    float roll  = HDiffBar(RxBar, "Roll" , oroll , 0.2f);
    float pitch = HDiffBar(RyBar, "Pitch", opitch, 0.2f);
    float yaw   = HDiffBar(RzBar, "Yaw"  , oyaw  , 0.2f);
    //NormBar(HScrollbar bar, String txt, float val, float min, float max, boolean Constrain)
    if(roll != oroll || pitch != opitch || yaw != oyaw){
      roll /= 2;
      pitch = constrain(pitch, -PI/2 + 0.001f, PI/2 - 0.001f) / 2;
      yaw /= 2;
      Q.w = cos(roll) * cos(pitch) * cos(yaw) + sin(roll) * sin(pitch) * sin(yaw);
      Q.i = sin(roll) * cos(pitch) * cos(yaw) - cos(roll) * sin(pitch) * sin(yaw);
      Q.j = cos(roll) * sin(pitch) * cos(yaw) + sin(roll) * cos(pitch) * sin(yaw);
      Q.k = cos(roll) * cos(pitch) * sin(yaw) - sin(roll) * sin(pitch) * cos(yaw);
      UpdateBasisMatrix();
      preresUpdate = true;
    }
    translate(0, -offset);
  }
  
   public void Rotate(Quaternion q){
    Q.PreMultiply(q);
    UpdateBasisMatrix();
  }
  
   public void RotatePost(Quaternion q){
    Q.PostMultiply(q);
    UpdateBasisMatrix();
  }
  
   public void SetRotation(Quaternion q){
    Q = q.copy();
    UpdateBasisMatrix();
  }
  
   public void setScale(PVector scale){
    this.scale = new PVector(1 / scale.x, 1 / scale.y, 1 / scale.z);
    this.invScale = scale.copy();
  }
  
   public void setScale(float scale){
    float is = 1 / scale;
    this.scale = new PVector(is, is, is);
    invScale = new PVector(scale, scale, scale);
  }
  
   public void UpdateBasisMatrix(){
    basisMatrix[0] = Q.ApplyTo(new PVector(1, 0, 0));
    basisMatrix[1] = Q.ApplyTo(new PVector(0, 1, 0));
    basisMatrix[2] = Q.ApplyTo(new PVector(0, 0, 1));
  }
  
   public PVector ApplyBasisMatrixScaled(PVector v){
    return new PVector(v.dot(basisMatrix[0]) * scale.x, v.dot(basisMatrix[1]) * scale.y, v.dot(basisMatrix[2]) * scale.z);
  }
  
   public PVector ApplyBasisMatrix(PVector v){
    return new PVector(v.dot(basisMatrix[0]), v.dot(basisMatrix[1]), v.dot(basisMatrix[2]));
  }
  
   public PVector ApplyInverseBasisMatrix(PVector v){
    return new PVector(v.x * basisMatrix[0].x + v.y * basisMatrix[1].x + v.z * basisMatrix[2].x,
                       v.x * basisMatrix[0].y + v.y * basisMatrix[1].y + v.z * basisMatrix[2].y,
                       v.x * basisMatrix[0].z + v.y * basisMatrix[1].z + v.z * basisMatrix[2].z);
  }
  
   public PVector ApplyInverseBasisMatrixScaled(PVector vec){
    PVector v = multEle(vec, invScale);
    return new PVector(v.x * basisMatrix[0].x + v.y * basisMatrix[1].x + v.z * basisMatrix[2].x,
                       v.x * basisMatrix[0].y + v.y * basisMatrix[1].y + v.z * basisMatrix[2].y,
                       v.x * basisMatrix[0].z + v.y * basisMatrix[1].z + v.z * basisMatrix[2].z);
  }
}

HScrollbar radiusBar = new HScrollbar(120, 10, 120, 12);
class Sphere extends Object{
  float rad;
  
  Sphere(PVector pos, float rad, Material mat){
    super(pos, mat);
    this.rad = rad;
  }
  
   public boolean Trace(Ray r, Hit h){
    PVector rpos = PVector.sub(r.pos, pos);
    float Dot = r.dir.dot(rpos);
    float del = Dot * Dot - rpos.dot(rpos) + rad * rad;
    
    if(del < 0){
      return false;
    }
    del = sqrt(del);
    float d = min(-Dot + del, -Dot - del);
    if(d < 0){
      d = max(-Dot + del, -Dot - del);
    }

    if(d < 0 || d > h.dist){
      return false;
    }
    
    h.dist = d;
    PVector hpos = PVector.mult(r.dir, d).add(r.pos);
    h.normal = PVector.sub(hpos, pos).normalize();
    h.shadedNormal = h.normal;
    h.object = this;
    if(invertNormals){
      h.normal.mult(-1);
    }
    return true;
  }
  
   public float getGuiSize(){
    return 30;
  }
  
   public PVector getUVCords(PVector hpos){
    PVector rpos = PVector.sub(hpos, pos).normalize();
    return new PVector((atan2(rpos.y, rpos.x) / TAU + 1.5f) % 1, acos(rpos.z) / PI);
  }
  
   public void drawGui(){
    rad = max(HDiffBar(radiusBar, "Radius", rad, 0.2f), 0);
  }
}

HScrollbar sxBar = new HScrollbar(120, 80, 120, 12);
HScrollbar syBar = new HScrollbar(120, 100, 120, 12);
class Plane extends Object{
  float w, h;
  
  Plane(PVector pos, PVector norm, float w, float h, float angle, Material mat){
    super(pos, mat);
    this.w = w;
    this.h = h;
    SetRotation(GetRotationTo(norm, angle));
  }
  
   public boolean Trace(Ray r, Hit h){
    PVector rpos = PVector.sub(r.pos, pos);
    
    if(rpos.dot(basisMatrix[2]) * r.dir.dot(basisMatrix[2]) > 0){
      return false;
    }
    
    float d = -rpos.dot(basisMatrix[2]) / r.dir.dot(basisMatrix[2]);
    if(d > h.dist || d < 0){
      return false;
    }
    
    //PVector hpos = PVector.mult(r.dir, d).add(r.pos);
    PVector rhpos = PVector.mult(r.dir, d).add(rpos);//PVector.sub(hpos, pos);
    if(abs(rhpos.dot(basisMatrix[0])) > this.w || abs(rhpos.dot(basisMatrix[1])) > this.h){
      return false;
    }
    
    //h.pos = hpos;
    h.object = this;
    h.dist = d;
    h.uv.u = 0.5f * (rhpos.dot(basisMatrix[0]) + this.w) / this.w;
    h.uv.v = 0.5f * (rhpos.dot(basisMatrix[1]) + this.h) / this.h;
    CopyTo(h.normal, basisMatrix[2]);
    h.shadedNormal = h.normal;
    
    return true;
  }
  
   public float getGuiSize(){
    return 120;
  }
  
   public void drawGui(){
    DrawRotationGUI(0);
    
    w = max(HDiffBar(sxBar, "Width", w, 0.2f), 0);
    h = max(HDiffBar(syBar, "Height", h, 0.2f), 0);
  }
  
   public PVector getUVCords(PVector hpos){
    PVector p = ApplyBasisMatrix(PVector.sub(hpos, pos));
    p.x -= w;
    p.y -= h;
    p.z = max(w, h);
    return p;
  }
}

class Disc extends Object{
  float rad;
  
  Disc(PVector pos, PVector norm, float rad, Material mat){
    super(pos, mat);
    this.rad = rad;
    SetRotation(GetRotationTo(norm, 0));
    //println(pointing);
  }
  
   public boolean Trace(Ray r, Hit h){
    PVector rpos = PVector.sub(r.pos, pos);
    
    if(rpos.dot(basisMatrix[2]) * r.dir.dot(basisMatrix[2]) > 0){
      return false;
    }
    
    float d = -rpos.dot(basisMatrix[2]) / r.dir.dot(basisMatrix[2]);
    if(d > h.dist || d < 0){
      return false;
    }
    
    //PVector hpos = PVector.mult(r.dir, d).add(r.pos);
    PVector rhpos = PVector.mult(r.dir, d).add(rpos);//PVector.sub(hpos, pos);
    if(rhpos.cross(basisMatrix[2]).magSq() > rad * rad){
      return false;
    }
    
    //h.pos = hpos;
    h.object = this;
    h.dist = d;
    
    CopyTo(h.normal, basisMatrix[2]);
    h.shadedNormal = h.normal;
    
    return true;
  }
  
   public float getGuiSize(){
    return 100;
  }
  
   public void drawGui(){
    rad = max(HDiffBar(radiusBar, "Radius", rad, 0.2f), 0);
    
    DrawRotationGUI(30);
  }
  
   public PVector getUVCords(PVector hpos){
    PVector p = ApplyBasisMatrix(PVector.sub(hpos, pos));
    p.x -= rad;
    p.y -= rad;
    p.z = rad;
    return p;
  }
}

HScrollbar sizeXBar = new HScrollbar(120, 10, 120, 12);
HScrollbar sizeYBar = new HScrollbar(120, 30, 120, 12);
HScrollbar sizeZBar = new HScrollbar(120, 50, 120, 12);
class Box extends Object {
  PVector dims;
  
  Box(PVector pos, PVector dims, Material mat){
    super(pos, mat);
    this.dims = dims;
  }
  
   public boolean Trace(Ray r, Hit h){
    PVector rpos = PVector.sub(r.pos, pos);
    
    rpos = ApplyBasisMatrix(rpos);
    PVector rdir = ApplyBasisMatrix(r.dir);
    
    float  tmin = (-dims.x * Sign(rdir.x) - rpos.x) / rdir.x;
    float  tmax = ( dims.x * Sign(rdir.x) - rpos.x) / rdir.x;
    float tymin = (-dims.y * Sign(rdir.y) - rpos.y) / rdir.y;
    float tymax = ( dims.y * Sign(rdir.y) - rpos.y) / rdir.y;
    
    if(tmin > tymax || tymin > tmax){
      return false;
    }
    
    tmin = max(tmin, tymin);
    tmax = min(tmax, tymax);
    
    float tzmin = (-dims.z * Sign(rdir.z) - rpos.z) / rdir.z;
    float tzmax = ( dims.z * Sign(rdir.z) - rpos.z) / rdir.z;
    
    if(tmin > tzmax || tzmin > tmax){
      return false;
    }
    
    tmin = max(tzmin, tmin);
    tmax = min(tzmax, tmax);
    
    if(tmin < 0){
      tmin = tmax;
    }
    if(tmin < 0 || tmin > h.dist){
      return false;
    }
    
    h.dist = tmin;
    //h.pos = PVector.mult(r.dir, tmin).add(r.pos);
    h.object = this;
    
    rpos.add(PVector.mult(rdir, tmin));//PVector.sub(h.pos, pos);
    
    h.normal = new PVector(rpos.x / dims.x, rpos.y / dims.y, rpos.z / dims.z);
    if(abs(h.normal.x) > abs(h.normal.y) && abs(h.normal.x) > abs(h.normal.z)){
      h.normal = PVector.mult(basisMatrix[0], Sign(rpos.x));
    }else if(abs(h.normal.y) > abs(h.normal.z)){
      h.normal = PVector.mult(basisMatrix[1], Sign(rpos.y));
    }else{
      h.normal = PVector.mult(basisMatrix[2], Sign(rpos.z));
    }
    h.shadedNormal = h.normal;
    
    //h.normal
    
    return true;
  }
  
   public float getGuiSize(){
    return 140;
  }
  
   public void drawGui(){
    dims.x = max(HDiffBar(sizeXBar, "X Size", dims.x, 0.2f), 0.0001f);
    dims.y = max(HDiffBar(sizeYBar, "Y Size", dims.y, 0.2f), 0.0001f);
    dims.z = max(HDiffBar(sizeZBar, "Z Size", dims.z, 0.2f), 0.0001f);
    
    DrawRotationGUI(70);
  }
  
   public PVector getUVCords(PVector hpos){
    PVector p = ApplyBasisMatrix(PVector.sub(hpos, pos));
    float maxp = max(max(p.x, p.y), p.z);
    if(maxp == p.x){
      p.x = p.y;
      p.y = p.z;
      p.z = max(dims.y, dims.z);
    }else if(maxp == p.y){
      p.y = p.z;
      p.z = max(dims.x, dims.z);
    }else if(maxp == p.z){
      p.z = max(dims.x, dims.y);
    }
    return p;
  }
}

class Triangle extends Object implements Primitive{
  private final PVector[] Vs = new PVector[3];
  //private float minX, maxX;
  PVector norm; // 'local' normal will always be 0,0,1 as all rotation will be handeled by the 'global' object rotation
  
  Triangle(PVector pos, PVector V1, PVector V2, PVector V3, Material mat){
    super(pos, mat);
    Vs[0] = V1;
    Vs[1] = V2;
    Vs[2] = V3;
    UpdateNormal();
  }
  
  Triangle(PVector pos, PVector[] verts, Material mat){
    super(pos, mat);
    assert(verts.length >= 3);
    for(int i = 0; i < 3; i++){
      Vs[i] = verts[i].copy();
    }
    UpdateNormal();
  }
  
  PVector normal;
   public void UpdateNormal(){
    /*for(int i = 0; i < 3; i++){
      Vs[i].add(pos);
    }
    normal = PVector.sub(Vs[1], Vs[0]).cross(PVector.sub(Vs[2], Vs[0])).normalize();*/
    
    boolean verbose = false;
    pos.add(Vs[0]);
    for(int i = 1; i < 3; i++){
      Vs[i].sub(Vs[0]);
    }
    Vs[0] = new PVector(0, 0, 0);
    
    if(verbose){
      println("======");
      for(int i = 0; i < 3; i++){
        println(Vs[i], Vs[i].mag(), PVector.sub(Vs[i], Vs[(i + 1)%3]).mag());
      }
    }
    
    PVector norm = Vs[1].cross(Vs[2]);
    Quaternion Nrot = GetRotationTo(norm, 0);
    Nrot.Invert();
    for(int i = 1; i < 3; i++){
      Vs[i] = Nrot.ApplyTo(Vs[i]);
      //Vs[i].z = 0;
    }
    Nrot.Invert();
    Rotate(Nrot);
    //println("norm: ",  norm);
    
    if(verbose){
      println("A");
      for(int i = 0; i < 3; i++){
        println(Vs[i], Vs[i].mag(), PVector.sub(Vs[i], Vs[(i + 1)%3]).mag());
      }
    }
    
    if(Vs[1].cross(Vs[2]).z < 0){
      PVector t = Vs[1];
      Vs[1] = Vs[2];
      Vs[2] = t;
    }
    
    //Vs[1].x *= -1;
    //Vs[2].mult(-1);
    if(verbose){
      println("B");
      for(int i = 0; i < 3; i++){
        println(Vs[i], Vs[i].mag(), PVector.sub(Vs[i], Vs[(i + 1)%3]).mag());
      }
    }
    
    //float co = abs(Vs[1].x) / Vs[1].mag();
    Quaternion Q = new Quaternion(Vs[1].mag() + abs(Vs[1].x), 0, 0, -Vs[1].y * Sign(Vs[1].x));
    //println(Q);
    Vs[1] = Q.ApplyTo(Vs[1]);
    Vs[2] = Q.ApplyTo(Vs[2]);
    Q.Invert();
    RotatePost(Q);
    
    if(verbose){
      println("===C===");
      for(int i = 0; i < 3; i++){
        println(Vs[i], Vs[i].mag(), PVector.sub(Vs[i], Vs[(i + 1)%3]).mag());
      }
    }
    
    if(Vs[2].y < 0){
      Quaternion Q2 = new Quaternion(0, 1, 0, 0); // 180 deg rotation around the X axis
      RotatePost(Q2);
      Vs[2].y *= -1;
    }
    
    if(Vs[1].x < 0){
      Quaternion Q2 = new Quaternion(0, 0, 1, 0); // 180 deg rotation around the Y axis
      RotatePost(Q2);
      Vs[1].x *= -1;
      Vs[2].x *= -1;
    }
    norm = basisMatrix[2].copy();
    basisMatrix[0].div(Vs[1].x);
    
    Vs[2].x /= Vs[1].x;
    Vs[1].x = 1;
    
    basisMatrix[1].div(Vs[2].y);
    Vs[2].y = 1;
    
    //minX = min(0, Vs[2].x);
    //maxX = max(Vs[1].x, Vs[2].x);
    
    if(verbose){
      println("===D===");
      for(int i = 0; i < 3; i++){
        println(Vs[i], Vs[i].mag(), PVector.sub(Vs[i], Vs[(i + 1)%3]).mag());
      }
    }
  }
  
   public void getBoundingBox(PVector TL, PVector BR){
    PVector T = ApplyInverseBasisMatrix(Vs[0]);
    CopyTo(TL, T);
    CopyTo(BR, T);
    for(int i = 1; i < 3; i++){
      T = ApplyInverseBasisMatrix(Vs[i]);
      TL.x = min(TL.x, T.x); BR.x = max(BR.x, T.x);
      TL.y = min(TL.y, T.y); BR.y = max(BR.y, T.y);
      TL.z = min(TL.z, T.z); BR.z = max(BR.z, T.z);
    }
    TL.add(pos);
    BR.add(pos);
  }
  
   public boolean Trace(Ray r, Hit h){
    /*PVector v0v1 = PVector.sub(Vs[1], Vs[0]); // copied from scratch-a-pixel
    PVector v0v2 = PVector.sub(Vs[2], Vs[0]);
    
    PVector pvec = r.dir.cross(v0v2);
    float invDet = 1.0 / v0v1.dot(pvec);
    
    //float invDet = 1.0 / det;
    PVector tvec = PVector.sub(r.pos, Vs[0]);
    float u = tvec.dot(pvec) * invDet;
    if(u < 0 || u > 1){return false;}
    
    PVector qvec = tvec.cross(v0v1);
    float v = r.dir.dot(qvec) * invDet;
    if(v < 0 || v + u > 1){return false;}
    
    float d = v0v2.dot(qvec) * invDet;
    
    if(d < 0 || h.dist < d){return false;}
    
    h.normal = normal.copy();
    h.dist = d;
    h.pos = PVector.mult(r.dir, d).add(r.pos);
    h.object = this;
    
    return true;*/
    
    PVector rpos = PVector.sub(r.pos, pos);
    
    float rpz = rpos.dot(basisMatrix[2]);
    float rdz = r.dir.dot(basisMatrix[2]);
    
    if((rpz < 0) == (rdz < 0)){
      return false;
    }

    float d = -rpz / rdz;
    if(h.dist < d){
      return false;
    }
    
    //PVector hpos = PVector.mult(r.dir, d).add(r.pos);
    PVector lhpos = PVector.mult(r.dir, d).add(rpos);//PVector.sub(hpos, pos);
    float hy = lhpos.dot(basisMatrix[1]);
    if(hy < 0 || 1 < hy){//(Vs[2].y < 0 || hy > Vs[2].y) ^ (hy < 0)){// 
      return false;
    }
    float hx = lhpos.dot(basisMatrix[0]) - Vs[2].x * hy;
    if(/*hx < minX || maxX < hx ||
          (Vs[2].y * hx - Vs[2].x * hy) < 0 ||
          (Vs[2].y * (Vs[1].x - hx) + hy * (Vs[2].x - Vs[1].x)) < 0*/ hx < 0 || hx + hy > 1){
      return false;
    }
    
    //h.pos = hpos;
    h.object = this;
    h.dist = d;
    
    CopyTo(h.normal, basisMatrix[2]);
    h.shadedNormal = h.normal;
    
    return true;
  }
  
   public float getGuiSize(){
    return 120;
  }
  
   public void drawGui(){
    DrawRotationGUI(0);
  }
  
   public PVector getUVCords(PVector hpos){
    PVector p = ApplyBasisMatrix(PVector.sub(hpos, pos));
    return p;
  }
}

HScrollbar objectScaleBar = new HScrollbar(120, 0, 120, 12);
CheckBox objectSmoothShadeCheckbox = new CheckBox(30, 15, 100, 12, "Smooth Shade");

class Mesh extends Object {
  PVector[] verts;
  int[] faces;
  
  PVector[] vertNorms;
  int[] vnInds;
  
  UV[] vertUVs;
  int[] uvInds;
  
  float radSq;
  KDTree tree;
  boolean smoothShading = true;
  boolean useUVs = true;
  MeshTriangle[] mesh;
  
  Mesh(PVector pos, String fileName, boolean trySmoothShade, boolean tryUseUVs, Material mat){
    super(pos, mat);
    radSq = 0;
    smoothShading = trySmoothShade;
    useUVs = tryUseUVs;
    LoadTris(ReadOBJ(fileName));
  }
  
   public void LoadTris(ObjParts objprts){
    verts = objprts.verts;
    vertNorms = objprts.vertNorms;
    vnInds = objprts.vnInds;
    vertUVs = objprts.vertUVs;
    uvInds = objprts.uvInds;
    
    useUVs &= uvInds != null;
    smoothShading &= vnInds != null;
    
    mesh = new MeshTriangle[objprts.faces.length / 3];
    
    for(int i = 0; i < mesh.length; i++){
      mesh[i] = new MeshTriangle(i, objprts.faces[i * 3], objprts.faces[i * 3 + 1], objprts.faces[i * 3 + 2]);
    }
    
    tree = new KDTree(mesh);
    println("Nodes: " + tree.nodes.length + " ; Faces: " + mesh.length);
  }
  
   public boolean Trace(Ray r, Hit h){
    PVector rpos = PVector.sub(r.pos, pos);
    
    PVector trpos = ApplyBasisMatrixScaled(rpos);
    PVector trdir = ApplyBasisMatrix(r.dir);
    Ray transRay = new Ray(trpos, trdir);
    Hit localHit = new Hit();
    localHit.dist = h.dist * scale.x;
    
    if(!tree.Trace(transRay, localHit)){
      return false;
    }
    
    h.dist = localHit.dist / scale.x;
    
    //h.pos = ApplyInverseBasisMatrixScaled(localHit.pos).add(pos);
    //h.pos = PVector.mult(r.dir, h.dist).add(r.pos);
    h.object = this;
    
    int hitInd = (int)localHit.normal.x;
    h.normal = mesh[hitInd].getNormal();
    if(smoothShading){
      h.shadedNormal = mesh[hitInd].getShadedNormal(localHit.normal.y, localHit.normal.z);
    }else{
      h.shadedNormal = h.normal.copy();
    }
    h.uv = mesh[hitInd].getUV(localHit.normal.y, localHit.normal.z);
    //h.normal = ApplyInverseBasisMatrix(h.normal).normalize();
    
    return true;
  }
  
   public void drawGui(){
    float change = HDiffBar(objectScaleBar, "Scale", 1 / scale.x, 0.1f); // +- 0.1
    setScale(max(change, 0.00001f));
    
    objectSmoothShadeCheckbox.setEnabled(vertNorms != null);
    objectSmoothShadeCheckbox.setState(smoothShading);
    objectSmoothShadeCheckbox.display();
    objectSmoothShadeCheckbox.update();
    if(objectSmoothShadeCheckbox.state != smoothShading){ // changed
      smoothShading = !smoothShading;
      preresUpdate = true;
    }
  }
  
   public float getGuiSize(){
      return 50;
  }
  
   public PVector getUVCords(PVector hpos){
    return new PVector(0, 0);
  }
  
  private class MeshTriangle implements Primitive {
    int v0, v1, v2;
    int ind;
    MeshTriangle(int ind, int v0, int v1, int v2){
      this.ind = ind;
      this.v0 = v0;
      this.v1 = v1;
      this.v2 = v2;
    }
    
     public void getBoundingBox(PVector TL, PVector BR){
      CopyTo(TL, verts[v0]);
      CopyTo(BR, verts[v0]);
      
      TL.x = min(TL.x, verts[v1].x); TL.y = min(TL.y, verts[v1].y); TL.z = min(TL.z, verts[v1].z);
      BR.x = max(BR.x, verts[v1].x); BR.y = max(BR.y, verts[v1].y); BR.z = max(BR.z, verts[v1].z);
      
      TL.x = min(TL.x, verts[v2].x); TL.y = min(TL.y, verts[v2].y); TL.z = min(TL.z, verts[v2].z);
      BR.x = max(BR.x, verts[v2].x); BR.y = max(BR.y, verts[v2].y); BR.z = max(BR.z, verts[v2].z);
    }
    
     public boolean Trace(Ray r, Hit h){
      PVector v0v1 = PVector.sub(verts[v1], verts[v0]); // Moller-Trombore alorithm, copied from scratch-a-pixel
      PVector v0v2 = PVector.sub(verts[v2], verts[v0]);
      
      PVector pvec = r.dir.cross(v0v2);
      float invDet = 1.0f / v0v1.dot(pvec);
      
      //float invDet = 1.0 / det;
      PVector tvec = PVector.sub(r.pos, verts[v0]);
      float u = tvec.dot(pvec) * invDet;
      if(u < 0 || u > 1){return false;}
      
      PVector qvec = tvec.cross(v0v1);
      float v = r.dir.dot(qvec) * invDet;
      if(v < 0 || v + u > 1){return false;}
      
      float d = v0v2.dot(qvec) * invDet;
      
      if(d < 0 || h.dist < d){return false;}
      
      h.dist = d;
      h.normal.x = ind;
      h.normal.y = u;
      h.normal.z = v;
      
      return true;
    }
    
     public PVector getNormal(){
      return ApplyInverseBasisMatrix(PVector.sub(verts[v1], verts[v0]).cross(PVector.sub(verts[v2], verts[v0])).normalize());
    }
    
     public PVector getShadedNormal(float u, float v){
      int b = ind * 3;
      PVector sn = PVector.mult(vertNorms[vnInds[b]], 1 - u - v).add(PVector.mult(vertNorms[vnInds[b+1]], u)).add(PVector.mult(vertNorms[vnInds[b+2]], v));
      sn = ApplyInverseBasisMatrix(sn);
      //PVector tn = ApplyInverseBasisMatrix(PVector.sub(verts[v1], verts[v0]).cross(PVector.sub(verts[v2], verts[v0])));
      /*if((tn.dot(r.dir) * sn.dot(r.dir) < 0)){
        //sn.mult(-1);
        return tn.normalize();
      }*/
      return sn.normalize();
    }
    
     public UV getUV(float u, float v){
      if(!useUVs){
        return new UV(u, v);
      }
      int b = ind * 3;
      UV uv0 = vertUVs[uvInds[  b  ]];
      UV uv1 = vertUVs[uvInds[b + 1]];
      UV uv2 = vertUVs[uvInds[b + 2]];
      return new UV(uv0.u * (1 - u - v) + uv1.u * u + uv2.u * v,
                    uv0.v * (1 - u - v) + uv1.v * u + uv2.v * v);
    }
  }
}

class Instance extends Object {
  Object obj;
  Instance(Object obj, PVector pos, Material mat){
    super(pos, mat);
    this.obj = obj;
  }
  
   public void drawGui(){
    obj.drawGui();
  }
  
   public float getGuiSize(){
    return obj.getGuiSize();
  }
  
   public boolean Trace(Ray r, Hit h){
    PVector rpos = obj.ApplyInverseBasisMatrixScaled(ApplyBasisMatrixScaled(PVector.sub(r.pos, pos))).add(obj.pos);
    PVector rdir = obj.ApplyInverseBasisMatrix(ApplyBasisMatrix(r.dir));
    Ray localRay = new Ray(rpos, rdir);
    
    if(!obj.Trace(localRay, h)){return false;}
    
    h.normal = ApplyInverseBasisMatrix(obj.ApplyBasisMatrix(h.normal));
    //h.pos = ApplyInverseBasisMatrixScaled(obj.ApplyBasisMatrixScaled(PVector.sub(h.pos, obj.pos))).add(pos);
    h.object = this;
    return true;
  }
  
   public PVector getUVCords(PVector hpos){
    return obj.getUVCords(hpos);
  }
}
class Quaternion {
  float w, i, j, k;
  Quaternion(float w, float i, float j, float k){
    this.w = w;
    this.i = i;
    this.j = j;
    this.k = k;
    normalize();
  }
  
  Quaternion(float w, float i, float j, float k, boolean norm){
    this.w = w;
    this.i = i;
    this.j = j;
    this.k = k;
    if(norm){normalize();}
  }
  
   public void normalize(){
    float l = sqrt(w * w + i * i + j * j + k * k);
    w /= l;
    i /= l;
    j /= l;
    k /= l;
  }
  
   public PVector getVector(){
    Quaternion o = new Quaternion(-i, w, k, -j);
    Quaternion inv = new Quaternion(w, -i, -j, -k);
    o = Mult(o, inv);
    return new PVector(o.i, o.j, o.k);
  }
  
   public float getAngle(){
    Quaternion o = new Quaternion(-i, w, k, -j);
    Quaternion inv = new Quaternion(w, -i, -j, -k);
    o = Mult(o, inv);
    return acos(o.w) * 2;
  }
  
   public Quaternion PostMultiply(float aw, float ai, float aj, float ak){ // rotates about global axis
    float tw = w * aw - i * ai - j * aj - k * ak;
    float ti = w * ai + i * aw + j * ak - k * aj;
    float tj = w * aj - i * ak + j * aw + k * ai;
          k  = w * ak + i * aj - j * ai + k * aw;
    w = tw;
    i = ti;
    j = tj;
    return this;
  }
  
   public Quaternion PostMultiply(Quaternion A){ // rotates about global axis
    PostMultiply(A.w, A.i, A.j, A.k);
    return this;
  }
  
   public Quaternion PreMultiply(float aw, float ai, float aj, float ak){ // rotates about local axis
    float tw = aw * w - ai * i - aj * j - ak * k;
    float ti = aw * i + ai * w + aj * k - ak * j;
    float tj = aw * j - ai * k + aj * w + ak * i;
          k  = aw * k + ai * j - aj * i + ak * w;
    w = tw;
    i = ti;
    j = tj;
    return this;
  }
  
   public Quaternion PreMultiply(Quaternion A){ // rotates about local axis
    PreMultiply(A.w, A.i, A.j, A.k);
    return this;
  }
  
   public Quaternion Rotate(float aw, float ai, float aj, float ak){
    PreMultiply(aw, ai, aj, ak);
    PostMultiply(aw, -ai, -aj, -ak);
    return this;
  }
  
   public Quaternion copy(){
    return new Quaternion(w, i, j, k);
  }
  
   public String toString(){
    return "(" + w + ", " + i + ", " + j + ", " + k + ")";
  }
  
   public PVector ApplyTo(PVector v){
    PVector q = new PVector(i, j, k);
    PVector t = q.cross(v).mult(2);
    return PVector.mult(t, w).add(v).add(q.cross(t));
  }
  
   public void Invert(){
    i *= -1;
    j *= -1;
    k *= -1;
  }
}

 public Quaternion Mult(Quaternion A, Quaternion B){
  return new Quaternion(A.w * B.w - A.i * B.i - A.j * B.j - A.k * B.k,
                        A.w * B.i + A.i * B.w + A.j * B.k - A.k * B.j,
                        A.w * B.j - A.i * B.k + A.j * B.w + A.k * B.i,
                        A.w * B.k + A.i * B.j - A.j * B.i + A.k * B.w, false);
}

 public Quaternion GetRotationTo(PVector vector, float angle){
  PVector v = vector.copy().normalize();
  Quaternion out;
  if(v.z < -0.9999f){
    PVector ov = orthVector(v);
    out = new Quaternion(0, ov.x, ov.y, ov.z);
  }else{
    out = new Quaternion(1 + v.z, -v.y, v.x, 0);
  }
  //Quaternion out = GetRotationBetween(new PVector(0, 0, 1), v);
  float sa = sin(angle / 2);
  out.PreMultiply(cos(angle / 2), sa * v.x, sa * v.y, sa * v.z);
  return out;
}

 public Quaternion GetRotationAbout(PVector vector, float angle){
  PVector v = vector.copy().normalize();
  float sa = sin(angle / 2);
  v.mult(sa);
  return new Quaternion(cos(angle / 2), v.x, v.y, v.z, false);
}

 public Quaternion GetRotationBetween(PVector V1, PVector V2){ // returns the quaternions that maps V1 to V2 using the minimum rotation angle
  float tl = sqrt(V1.magSq() * V2.magSq());
  if(V1.dot(V2) < -0.999999f * tl){
    PVector ov = orthVector(V1).normalize();
    return new Quaternion(0, ov.x, ov.y, ov.z);
  }
  PVector a = V1.cross(V2);
  return new Quaternion(tl + V1.dot(V2), a.x, a.y, a.z);
}
int FrameNum = 1;
Color[] bloom;
float log255 = log(255);

 public void drawPreRes(){
  int st = millis();
  int iy;
  //Color c;
  Hit dummyHit = new Hit();
  //dummyHit.dist = 0;
  for(int j = 0; j < ImageHeight; j++){
    iy = j * ImageWidth;
    boolean lastInter = false;
    for(int i = 0; i < ImageWidth; i++){
      PVector x = Cam.Pos.copy();
      PVector dir = Cam.getRay(i, j);//PVector.add(PVector.add(Cam.p1m, PVector.mult(Cam.qx, (float)i-1)), PVector.mult(Cam.qy, (float)j-1)).normalize();
      //if(i == 300 && j == 300){println(Mult(Cam.qx, (float)i*Res-1), Mult(Cam.qy, (float)j*Res-1), Cam.p1m);}
      Ray r = new Ray(x, dir);
      
      dummyHit.dist = 10000;
      if(objectSelected){
        selObjectBuffer[iy + i] = selectedObject.Trace(r, dummyHit);
      }
      /*if(objectSelected && selectedObject.Trace(r, null) != lastInter){
        println("X");
        lastInter = !lastInter;
        image[iy + i] = new Color(0.988, 0.729, 0);
        continue;
      }*/
      
      image[iy + i] = getColor(r, 8, 1, i == mouseX/Res && j == mouseY/Res, true);
      
      if(drawingDepthBuffer){
        Hit h = new Hit();
        tracePath(r, h);
        depthBuffer[iy + i] = h.dist;
      }
      /*Hit h = new Hit();
      if(tracePath(r, h)){
        image[iy + i] = new Color((h.normal.x + 1) / 2, (h.normal.y + 1) / 2, (h.normal.z + 1) / 2);
      }else{
        image[iy + i] = new Color(0);
      }*/
      
      //image[iy + j].add(c);
      //buffer[iy + j] = c;
      //finalRender[iy + j] = c;
      /*for(int a = 0; a < Res; a++){
        for(int b = 0; b < Res; b++){
          pixels[i*Res + a + (j*Res + b)*width] = c;
        }
      }*/
    }
  }
  println("Draw Time: " + (millis() - st));
}

Color[] buffer;

 public void DrawFrameMT(){ // thread needs to check if preRes is true once in a while incase it needs to terminate itself
  //Time = millis();
  //int i = floor(width/2);
  //int j = floor(height/2);
  RenderTile[] tileArr = new RenderTile[tileSplit * tileSplit];
  int tilePxx = ceil((float)ImageWidth / tileSplit);
  int tilePxy = ceil((float)ImageWidth / tileSplit);
  //println("------");
  for(int ty = 0; ty < tileSplit; ty++){
    for(int tx = 0; tx < tileSplit; tx++){
      tileArr[ty * tileSplit + tx] = new RenderTile(tilePxx * tx, min(tilePxx * (tx+1), ImageWidth), tilePxy * ty, min(tilePxy * (ty+1), ImageHeight));
      //tileArr[ty * tileSplit + tx].start();
      //println(tilePxx * tx, min(tilePxx * (tx+1), ImageWidth), tilePxy * ty, min(tilePxy * (ty+1), ImageHeight));
    }
  }
  
  int[] running = new int[8];
  int next = 0;
  for(int i = 0; i < running.length; i++){running[i] = -1;}
  
  //boolean allDone = false;
  int numFinished = 0;
  while(numFinished < tileArr.length){
    for(int i = 0; i < running.length; i++){
      if(running[i] != -1 && tileArr[running[i]].finished){
        try{
          tileArr[running[i]].join();
        }catch(InterruptedException e){}
        running[i] = -1;
        numFinished++;
      }
      
      if(running[i] == -1 && next < tileArr.length){
        tileArr[next].start();
        running[i] = next++;
      }
    }
  }
  
  //println("X");
  /*for(int i = 0; i < tileArr.length; i++){
    //tileArr[i].join();
    //println(i);
    try{
      tileArr[i].join();
    }catch(InterruptedException e){
      //exit();
    }
    //println(tileArr[i].totalTraces);
    //totalTracedRays += tileArr[i].totalTraces;
  }*/
  
  //println("X");
  threadFinished.set(true);
  //println("Y");
}

 public PVector SampleAperature(float size){
  return PVector.random2D().mult(random(0, size)); // circle
}

class RenderTile extends Thread {
  int imin, imax, jmin, jmax;
  boolean finished;
  
  RenderTile(int imin, int imax, int jmin, int jmax){
    this.imin = imin;
    this.imax = imax;
    this.jmin = jmin;
    this.jmax = jmax;
    finished = false;
  }
  
  public void run(){
    int iy;
    PVector dir, x, focalPoint;
    //float dx, dy;
    PVector newPos, offset;
    for(int j = jmin; j < jmax; j++){
      iy = j * ImageWidth;
      for(int i = imin; i < imax; i++){
        x = Cam.Pos.copy();
        dir = PVector.add(PVector.add(Cam.p1m, PVector.mult(Cam.qx, (float)i-1+random(-0.5f, 0.5f))), PVector.mult(Cam.qy, (float)j-1+random(-0.5f, 0.5f))).normalize();
        //if(i == 300 && j == 300){println(Mult(Cam.qx, (float)i*Res-1), Mult(Cam.qy, (float)j*Res-1), Cam.p1m);}
        Ray r;
        if(apertureSize > 0){
          focalPoint = PVector.mult(dir, focalLength).add(Cam.Pos);
          offset = SampleAperature(apertureSize);//PVector.random2D().mult(random(0, apertureSize));
          //offset = new PVector(random(-1, 1), random(-1, 1)).mult(apertureSize);
          x = PVector.mult(Cam.b, offset.x).add(PVector.mult(Cam.v, offset.y)).add(Cam.Pos);
          
          dir = PVector.sub(focalPoint, x).normalize();
          r = new Ray(x, dir);
        }else{
          r = new Ray(Cam.Pos.copy(), dir);
        }
        
        buffer[iy + i] = getColor(r, maxBounces, 1, /*i == mouseX/Res && j == mouseY/Res*/ /*i == 82 && j == 77*/false, false);
        
        //image[iy + j].add(c);
        pixelsDrawn++;
      }
      if(preRes){finished = true;return;}
    }
    finished = true;
  }
}

 public int[] getObjectMap(){
  int[] out = new int[ImageHeight * ImageWidth];
  int iy;
  for(int j = 0; j < ImageHeight; j++){
    iy = j * ImageWidth;
    for(int i = 0; i < ImageWidth; i++){
      PVector x = Cam.Pos.copy();
      PVector dir = PVector.add(PVector.add(Cam.p1m, PVector.mult(Cam.qx, (float)i-1)), PVector.mult(Cam.qy, (float)j-1)).normalize();
      Ray r = new Ray(x, dir);
            
      Hit h = new Hit();
      if(tracePath(r, h)){
        out[iy + i] = Objs.indexOf(h.object);
      }else{
        out[iy + i] = -1;
      }
    }
  }
  
  return out;
}

 public int[] getNormalMap(){
  int[] out = new int[ImageHeight * ImageWidth];
  int iy;
  for(int j = 0; j < ImageHeight; j++){
    iy = j * ImageWidth;
    for(int i = 0; i < ImageWidth; i++){
      PVector x = Cam.Pos.copy();
      PVector dir = PVector.add(PVector.add(Cam.p1m, PVector.mult(Cam.qx, (float)i-1)), PVector.mult(Cam.qy, (float)j-1)).normalize();
      Ray r = new Ray(x, dir);
      
      Hit h = new Hit();
      if(tracePath(r, h)){
        out[iy + i] = (0xFF << 24) | ((int)((h.normal.x + 1) / 2) << 16) | ((int)((h.normal.y + 1) / 2) << 8) | (int)((h.normal.z + 1) / 2);
      }else{
        out[iy + i] = -1;
      }
    }
  }
  
  return out;
}
class Hit{
  UV uv = new UV();
  PVector normal = new PVector(0,0,0);
  PVector shadedNormal = new PVector(0,0,0);
  float dist;
  Object object;
  Hit(){}
}

class Ray{
  PVector pos, dir;
  
  Ray(PVector pos, PVector dir){
    this.pos = pos;
    this.dir = dir;
  }
}

class UV {
  float u = -1, v = -1;
  UV(){}
  UV(float u, float v){
    this.u = u;
    this.v = v;
  }
}

 public boolean tracePath(Ray r, Hit h){
  h.dist = 1000;
  
  for(Object o : Objs){
    o.Trace(r, h);
  }
  
  if(h.dist < 1000){
    return true;
  }else{
    return false;
  }
}
 public Color getColor(Ray r, int depth, float power, boolean verbose, boolean isPreRes){
  //Color out = new Color(0, 0, 0);
  if(depth == 0){
    return new Color(0);
  }
  
  if(power < 0.0002f){
    return new Color(0);
  }
  
  Hit h = new Hit();
  
  Color outputColor = null;
  
  raysThisFrame++;
  if(tracePath(r, h)){
    /*if(depth != -1){
      if(verbose){println(h.normal);}
      return new Color((h.normal.x + 1) / 2, (h.normal.y + 1) / 2, (h.normal.z + 1) / 2);
    }*/
    Material m = h.object.getMaterial();
    PVector hpos = PVector.mult(r.dir, h.dist).add(r.pos);
    
    if(m.getType() == 0){  // ====================================== Emissive ======================================
      Emissive e = (Emissive)m;
      outputColor = new Color(e.c).mult(e.strength);
    }else if(m.getType() == 1 || m.getType() == 5){  // ====================================== Diffuse ======================================
      Diffuse d = (Diffuse)m;
      
      if(power < 0.005f/*0.1 / (float)samples*/){
        return new Color(0);//d.albedo.copy();
      }
      
      if(h.normal.dot(r.dir) > 0){
        h.normal.mult(-1);
        h.shadedNormal.mult(-1);
      }
      Color colAlbedo = d.getAlbedo(h.uv);
      if(isPreRes){ // && !verbose
        return colAlbedo.mult(min(max(h.shadedNormal.dot(preResLightDir), 0) * 0.5f + 0.5f, 1));
      }
      
      if(depth <= 1){
        return new Color(0);//d.albedo.copy();
      }
      PVector Chpos = PVector.mult(h.normal, 0.0001f).add(hpos);
      
      Color inderLight = new Color(0);
      PVector X = orthVector(h.shadedNormal).normalize();
      PVector Y = h.normal.cross(X);
      float theta, cp/* = random(0, 1)*/, sp;//, t = random(0, 1);
      
      int bounceSamples = constrain((int)(power * power * samples), 1, samples);
      
      float powerFactor = colAlbedo.maxValue() * 2 * power / (float)bounceSamples;
      float sx = random(0, 1), sy = random(0, 1);
      //int sig = floor(random(0, samples));
      /*float b = sx;
      for(int i = 0; i < samples; i++){
        if((sx + goldenConj * i) % 1 < b){
          sig = i;
          b = (sx + goldenConj * i) % 1;
        }
      }*/
      if(verbose){
        //return new Color(0);
        //println(samples);
        //println("X");
      }
      
      for(int i = 0; i < bounceSamples; i++){
        theta = TAU * ((sx + (float)i * plasticConj) % 1);//((sx + goldenConj * i) % 1) * TAU;
        cp = ((sy + 2 * (float)i * plasticConj * plasticConj) % 1);//(sy + goldenConj * sig) % 1;
        //theta = random(0, TAU);
        //cp = random(0, 1);
        sp = sqrt(1 - cp * cp);
        //println(theta + ", " + cp);
        
        PVector dir = PVector.mult(X, cos(theta) * sp).add(PVector.mult(Y, sin(theta) * sp)).add(PVector.mult(h.shadedNormal, cp));
        //println("dir", dir, dir.dot(h.normal));
        
        //if(verbose){println(dir.dot(h.normal), cp, sp, (cp * cp + sp * sp));}
        //if(!preRes){
        inderLight.add(getColor(new Ray(Chpos, dir), depth - 1, cp * powerFactor, false, isPreRes).mult(cp));
        //}
        /*if(sig <= fibB){
          sig += fibA;
          if(sig > samples){sig -= fibB;}
        }else{
          sig -= fibB;
        }*/
      }
      
      inderLight.div(bounceSamples);
      
      //if(verbose){println(d.albedo);}
      
      if(verbose){
        //println(inderLight);
        //println(inderLight.r, inderLight.g, inderLight.b);
        //println(d.albedo.r, d.albedo.g, d.albedo.b);
        //println(h.pos);
        //println(h.normal);
      }
      
      //inderLight.div(samples);
      outputColor = dot(inderLight, colAlbedo).mult(2);
    }else if(m.getType() == 2){ // ====================================== Glossy ======================================
      Glossy g = (Glossy)m;
      
      if(h.normal.dot(r.dir) > 0){
        h.normal.mult(-1);
      }
      
      PVector reflDir = PVector.mult(h.normal, -2 * h.normal.dot(r.dir) * -Sign(h.normal.dot(r.dir))).add(r.dir).normalize();
      PVector Chpos = PVector.mult(h.normal, 0.0001f).add(hpos);
      
      if(isPreRes){
        Color ReflCol = getColor(new Ray(Chpos, reflDir), depth-1, power * g.albedo.maxValue(), false, isPreRes);
        return dot(ReflCol, g.albedo);
      }
      
      Color ReflCol = new Color(0);
      
      PVector dir;
      
      for(int i = 0; i < samples; i++){
        dir = PVector.random3D().mult(g.roughness).add(reflDir);
        if(h.normal.dot(dir) < 0){
          dir.sub(PVector.mult(h.normal, 2 * h.normal.dot(dir)));
        }
        
        dir.normalize();
        
        ReflCol.add(getColor(new Ray(Chpos, dir), depth-1, power * g.albedo.maxValue() / samples, false, isPreRes));
      }
      
      ReflCol.div(samples);
      
      outputColor = dot(ReflCol, g.albedo);
    }else if(m.getType() == 3){  // ====================================== Transparent ======================================
      Transparent t = (Transparent)m;
      //float nS = 2; // scale
      //float nA = 0.4; // amplitude
      //PVector nPos = PVector.div(h.pos, nS); // noisePosition
      //PVector nV = new PVector(noise(nPos.x + 100, nPos.y + 100) * nA * 2 - nA, noise(nPos.x + 10000, nPos.y + 100) * nA * 2 - nA, noise(nPos.x + 100, nPos.y + 10000) * nA * 2 - nA);
      //h.normal.add(nV).normalize();
      
      //float n1 = 1;
      //float n2 = t.ior;
      boolean inside = false;
      float iorR = 1 / t.ior;
      
      if(h.normal.dot(r.dir) > 0){ // object normals should always be facing outwards, this way internal collisions can be detected by this method
        //float n3 = n1;
        //n1 = n2;
        //n2 = n3;
        iorR = 1 / iorR;
        h.normal.mult(-1);
        inside = true;
      }
      
      PVector reflDir = PVector.mult(h.normal, -2 * h.normal.dot(r.dir) * -Sign(h.normal.dot(r.dir))).add(r.dir).normalize();
      //reflDir.add(PVector.random3D().mult(0.5)).normalize();
            
      PVector Chpos = PVector.mult(h.normal, -0.0001f).add(hpos);
      
      //float iorR = n1 / n2;
      
      /*float ndi = -h.normal.dot(r.dir);
      float v = 1 - iorR * iorR * (1 - ndi * ndi);
      if(v < 0){ // total interal reflection
        return getColor(new Ray(Chpos, reflDir), depth-1, power, false, isPreRes);
      }
      v = sqrt(v);*/
      //PVector tv = PVector.mult(h.normal, -v + iorR * ndi).add(PVector.mult(r.dir, iorR)).normalize();
      
      float ndi = h.normal.dot(r.dir);
      PVector nxd = h.normal.cross(r.dir);
      float v = 1 - iorR * iorR * nxd.dot(nxd);
      if(v < 0){ // total internal reflection, only draw reflected ray
        //if(verbose){println(depth, r.pos, r.dir, h.normal, reflDir);}
        //if(verbose){println("totally interally reflected");}
        //return new Color(0);
        return getColor(new Ray(PVector.mult(h.normal, 0.0001f).add(hpos), reflDir), depth-1, power, verbose, isPreRes);
        //return new Color(0, 1, 0);
      }
      //v = sqrt(v);
      PVector tv = h.normal.cross(nxd).mult(-iorR).sub(PVector.mult(h.normal, sqrt(v))).normalize();
      
      if(verbose){
        /*println("-------------");
        println(depth);
        println(h.pos);
        println(h.normal, r.dir);
        float ang = acos(-h.normal.dot(r.dir));
        println("a", ang * 180 / PI);
        println("b", acos(-h.normal.dot(tv)) * 180 / PI);
        println("c", asin(sin(ang) * iorR) * 180 / PI);
        println("stp", h.normal.cross(tv).dot(r.dir));
        println(iorR);
        println(v);
        println(ndi);
        println(tv);*/
      }
      
      float transmissionStrength = 1; // strength of transmission after some light is absorbed
      if(inside && t.absorbanceStrength > 0){
        transmissionStrength = 1 / pow(10, t.absorbanceStrength * h.dist);
      }
      
      if(verbose){
        /*println("===============");
        println(depth);
        println(inside);
        println(h.dist);
        println(transmissionStrength);*/
      }
      
      if(isPreRes){
        Color transColor = getColor(new Ray(Chpos, tv), depth-1, power * transmissionStrength, verbose, isPreRes);
        //return .dot(t.absorbance);
        if(inside && t.absorbanceStrength > 0){
          return dot(transColor, t.absorbance).mult(transmissionStrength);
        }else{
          return transColor;
        }
      }
      
      float ct = abs(ndi);
      float c = sqrt(1 - iorR * iorR * (1 - ndi * ndi));
      
      //float Rs = (n1 * ct - n2 * c) / (n1 * ct + n2 * c);
      float Rs = (iorR * ct - c) / (iorR * ct + c);
      Rs = min(Rs * Rs, 1);
      float Rp = (iorR * c - ct) / (iorR * c + ct);
      Rp = min(Rp * Rp, 1);
      
      float R = 0.5f * Rs + 0.5f * Rp; // percentage of light made up of reflected rays
      
      if(verbose){println(depth, r.pos, r.dir, hpos, h.normal, reflDir, tv, R);}
      
      if(verbose){
        //println("R", R);
      }
      
      Color TransCol, ReflCol;
      
      //ReflCol = getColor(new Ray(Chpos, reflDir), depth-1, false);
      //TransCol = getColor(new Ray(Chpos, tv), depth-1, verbose);
      //R = 0;
      /*if(R < 0.01){
        ReflCol = new Color(0);
        R = 0;
      }else{
        ReflCol = getColor(new Ray(Chpos, reflDir), depth, power * R, false, isPreRes);
      }
      
      if(R > 0.99){
        R = 1;
        TransCol = new Color(0);
      }else{
        TransCol = getColor(new Ray(Chpos, tv), depth-1, power*(1-R), verbose, isPreRes);
      }*/
      ReflCol = getColor(new Ray(PVector.mult(h.normal, 0.0001f).add(hpos), reflDir), depth-1, power * R, false, isPreRes);
      
      if(inside && t.roughness != 0){
        TransCol = new Color(0);
        
        float tp = power * (1-R) * transmissionStrength / 20;
        PVector dir;
        for(int i = 0; i < samples; i++){
          //if(random(0, 1) < t.roughness){
          dir = PVector.random3D().mult(t.roughness).add(tv);
          if(dir.dot(h.normal) > 0){
            dir.add(h.normal.copy().mult(2 * dir.dot(h.normal)));
          }
          //}else{
            
          //}
          
          TransCol.add(getColor(new Ray(Chpos, dir), depth-1, tp, verbose, isPreRes));
        }
        TransCol.div(samples);
      }else{
        TransCol = getColor(new Ray(Chpos, tv), depth-1, power * (1-R) * transmissionStrength, verbose, isPreRes);
      }
      
      if(inside && t.absorbanceStrength > 0){
        TransCol = dot(TransCol, t.absorbance).mult(transmissionStrength);
        //TransCol.sub(dot(TransCol, t.absorbance).mult(1 - transmissionStrength));
      }
      
      outputColor = lerpColor(TransCol, ReflCol, R);
    }else if(m.getType() == 4){  // ====================================== Metal ======================================
      Metal me = (Metal)m;
      
      if(h.normal.dot(r.dir) > 0){
        h.normal.mult(-1);
      }
      
      PVector reflDir = PVector.mult(h.normal, 2 * h.normal.dot(r.dir) * Sign(h.normal.dot(r.dir))).add(r.dir).normalize();
      
      Color ReflCol = getColor(new Ray(PVector.mult(h.normal, 0.001f).add(hpos), reflDir), depth-1, power * me.col.maxValue(), false, isPreRes);
      outputColor = dot(ReflCol, me.col);
    }
  }
  
  if(outputColor == null){
    outputColor = skyColor.copy().mult(skyBrightness);
    h.dist = MAX_FLOAT;
  }else{
    //outputColor = lerpColor(new Color(0.5), outputColor, exp(-h.dist / 30.0));
  }
  
  /*if(depth == maxBounces && !isPreRes){
    PVector selPos = PVector.mult(r.dir, random(0, max(h.dist, 30))).add(r.pos);
    PVector dir = PVector.random3D();
    Ray sr = new Ray(selPos, dir);
    
    float spower = 1 - exp(-h.dist / 50);
    
    Color scatterColor = getColor(sr, depth - 4, power * spower, false, isPreRes).mult(spower);
    
    outputColor.add(scatterColor);
  }*/
  
  return outputColor;
}


  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "Ray_Tracing_Global_Illumination_copy" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
